{
    "sourceFile": "agents/outputs.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765741931985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765741931985,
            "name": "Commit-0",
            "content": "from typing import TypedDict, Union\r\nfrom pydantic import Field\r\nfrom typing import TypedDict, Union\r\nimport json\r\nimport warnings\r\nimport nest_asyncio\r\nfrom langchain_ollama.chat_models import ChatOllama\r\nfrom langchain_core.messages import HumanMessage, AIMessage\r\n\r\n\r\n\r\nnest_asyncio.apply()\r\nwarnings.filterwarnings(\"ignore\", category=ResourceWarning)\r\n\r\nclass ExploitEvaluatorOutput(TypedDict):\r\n    should_terminate: bool = Field(\r\n        description=\"True if the pentest loop should terminate\"\r\n    )\r\n    reason: str = Field(description=\"Reason for verdict\")\r\n    successful_payload: Union[None, dict[str, str]] = Field(\r\n        description=\"\"\"\r\nIf the loop should terminate and the exploit was successful, this will contain the payload that were successful for each field.\r\nIt should look like this:\r\n\"payloads\": {\r\n    \"<field_name_1>\": \"<payload for field 1>\",\r\n    \"<field_name_2>\": \"<payload for field 2>\",\r\n    …           : …\r\n}\r\nElse, this field should be empty/null.\r\nReturn ONLY valid JSON.\r\nNO explanations. NO markdown. NO pre-text or post-text.\r\n\"\"\"\r\n    )\r\n\r\n\r\nclass AttackerOutput(TypedDict):\r\n    final_output: list[dict[str, Union[str, dict]]]\r\n\r\nclass PlannerOutput(TypedDict):\r\n    final_output: dict[str, Union[str, list]]\r\n\r\n\r\nclass CriticOutput(TypedDict):\r\n    final_output: dict[str, Union[list[dict], dict]]\r\n\r\n\r\nclass ScannerInputOutput(TypedDict):\r\n    \"\"\"\r\n    Output from the scanner input generator agent.\r\n    Contains the structured inputs that should be passed to the NoSQL scanner tool.\r\n    \"\"\"\r\n    scanner_tool_inputs: dict[str, Union[str, list, dict]] = Field(\r\n        description=\"\"\"\r\nThe inputs that should be passed to the NoSQL scanner tool.\r\nThis should contain all necessary parameters like:\r\n- target_url: The URL to scan\r\n- scan_depth: How deep to crawl\r\n- endpoints_to_test: List of endpoints\r\n- other scanner-specific parameters\r\n\"\"\"\r\n    )\r\n\r\n\r\ndef print_planner_output(data: dict) -> None:\r\n    \"\"\"\r\n    Pretty print Planner Agent output.\r\n    \"\"\"\r\n    print(\"\\n\" + \"=\"*80)\r\n    print(\"PLANNER AGENT OUTPUT\")\r\n    print(\"=\"*80)\r\n    \r\n    final_output = data.get(\"final_output\", [])\r\n    \r\n    for idx, entry in enumerate(final_output, 1):\r\n        print(f\"\\n[Entry Point #{idx}]\")\r\n        print(f\"  Entry Point: {entry.get('entry_point', 'N/A')}\")\r\n        print(f\"  Page URL: {entry.get('page_url', 'N/A')}\")\r\n        print(f\"  Justification: {entry.get('justification', 'N/A')}\")\r\n        \r\n        payload_sequence = entry.get('payload_sequence', [])\r\n        print(f\"\\n  Payload Sequence ({len(payload_sequence)} payload(s)):\")\r\n        \r\n        for pidx, payload in enumerate(payload_sequence, 1):\r\n            print(f\"\\n    [Payload #{pidx}]\")\r\n            print(f\"      Type: {payload.get('type', 'N/A')}\")\r\n            print(f\"      Reason: {payload.get('reason', 'N/A')}\")\r\n            print(f\"      Payloads:\")\r\n            \r\n            payloads_dict = payload.get('payloads', {})\r\n            for field_name, field_payload in payloads_dict.items():\r\n                print(f\"        - {field_name}: {field_payload}\")\r\n        \r\n        print(\"\\n\" + \"-\"*80)\r\n    \r\n    print()\r\n\r\n\r\ndef print_critic_output(data: dict) -> None:\r\n    \"\"\"\r\n    Pretty print Critic Agent output.\r\n    \"\"\"\r\n    print(\"\\n\" + \"=\"*80)\r\n    print(\"CRITIC AGENT OUTPUT\")\r\n    print(\"=\"*80)\r\n    \r\n    final_output = data.get(\"final_output\", {})\r\n    \r\n    print(\"\\n[ANALYSIS]\")\r\n    analysis_list = final_output.get(\"analysis\", [])\r\n    \r\n    for idx, analysis in enumerate(analysis_list, 1):\r\n        print(f\"\\n  Analysis #{idx}:\")\r\n        print(f\"    Entry Point: {analysis.get('entry_point', 'N/A')}\")\r\n        print(f\"    Page URL: {analysis.get('page_url', 'N/A')}\")\r\n        print(f\"    Reflection: {analysis.get('reflection', 'None')}\")\r\n        print(f\"    Analysis: {analysis.get('analysis', 'N/A')}\")\r\n        \r\n        print(f\"    Payloads Tested:\")\r\n        payloads = analysis.get('payloads', {})\r\n        for field_name, payload in payloads.items():\r\n            print(f\"      - {field_name}: {payload}\")\r\n        print()\r\n    \r\n    print(\"\\n[RECOMMENDATION]\")\r\n    recommendation = final_output.get(\"recommendation\", {})\r\n    print(f\"  Reason: {recommendation.get('reason', 'N/A')}\")\r\n    print(f\"  Recommended Payloads:\")\r\n    \r\n    rec_payloads = recommendation.get('payloads', {})\r\n    for field_name, payload in rec_payloads.items():\r\n        print(f\"    - {field_name}: {payload}\")\r\n    \r\n    print(\"\\n\" + \"=\"*80 + \"\\n\")\r\n\r\n\r\ndef print_attacker_output(data: dict) -> None:\r\n    \"\"\"\r\n    Pretty print Attacker Agent output.\r\n    \"\"\"\r\n    print(\"\\n\" + \"=\"*80)\r\n    print(\"ATTACKER AGENT OUTPUT\")\r\n    print(\"=\"*80)\r\n    \r\n    final_output = data.get(\"final_output\", [])\r\n    \r\n    for idx, attempt in enumerate(final_output, 1):\r\n        print(f\"\\n[Attempt #{idx}]\")\r\n        print(f\"  Entry Point: {attempt.get('entry_point', 'N/A')}\")\r\n        print(f\"  Page URL: {attempt.get('page_url', 'N/A')}\")\r\n        \r\n        print(f\"  Payloads:\")\r\n        payloads = attempt.get('payloads', {})\r\n        for field_name, payload in payloads.items():\r\n            print(f\"    - {field_name}: {payload}\")\r\n        \r\n        print(f\"\\n  Response Excerpt:\")\r\n        response = attempt.get('response_excerpt', 'N/A')\r\n        if len(response) > 200:\r\n            response = response[:200] + \"...\"\r\n        print(f\"    {response}\")\r\n        \r\n        print(f\"\\n  Notes: {attempt.get('notes', 'N/A')}\")\r\n        print(\"\\n\" + \"-\"*80)\r\n    \r\n    print()\r\n\r\n\r\ndef print_evaluator_output(data: dict) -> None:\r\n    \"\"\"\r\n    Pretty print Exploit Evaluator output.\r\n    \"\"\"\r\n    print(\"\\n\" + \"=\"*80)\r\n    print(\"EXPLOIT EVALUATOR OUTPUT\")\r\n    print(\"=\"*80)\r\n    \r\n    should_terminate = data.get('should_terminate', False)\r\n    reason = data.get('reason', 'N/A')\r\n    successful_payload = data.get('successful_payload')\r\n    \r\n    print(f\"\\n  Should Terminate: {should_terminate}\")\r\n    print(f\"  Reason: {reason}\")\r\n    \r\n    if successful_payload:\r\n        print(f\"\\n  Successful Payload:\")\r\n        for field_name, payload in successful_payload.items():\r\n            print(f\"    - {field_name}: {payload}\")\r\n    else:\r\n        print(f\"\\n  Successful Payload: None\")\r\n    \r\n    print(\"\\n\" + \"=\"*80 + \"\\n\")\r\n\r\n\r\ndef print_scanner_input_output(data: dict) -> None:\r\n    \"\"\"\r\n    Pretty print Scanner Input Generator output.\r\n    \"\"\"\r\n    print(\"\\n\" + \"=\"*80)\r\n    print(\"SCANNER INPUT GENERATOR OUTPUT\")\r\n    print(\"=\"*80)\r\n    \r\n    scanner_inputs = data.get(\"scanner_tool_inputs\", {})\r\n    \r\n    print(\"\\n  Scanner Tool Inputs:\")\r\n    for key, value in scanner_inputs.items():\r\n        if isinstance(value, (list, dict)):\r\n            print(f\"    {key}: {json.dumps(value, indent=6)}\")\r\n        else:\r\n            print(f\"    {key}: {value}\")\r\n    \r\n    print(\"\\n\" + \"=\"*80 + \"\\n\")\r\n\r\n    \r\ndef get_json_schema_prompt(schema_class: type) -> str:\r\n    \"\"\"\r\n    Generate a JSON schema prompt from a Pydantic TypedDict class.\r\n    \"\"\"\r\n    if schema_class.__name__ == \"CriticOutput\":\r\n        return \"\"\"\r\n{\r\n  \"final_output\": {\r\n    \"analysis\": [\r\n      {\r\n        \"entry_point\": \"string (FULL URL)\",\r\n        \"page_url\": \"string (FULL URL of the page with the form)\",\r\n        \"payloads\": {\r\n          \"field_name_1\": \"payload string\",\r\n          \"field_name_2\": \"payload string\"\r\n        },\r\n        \"reflection\": \"string or null (full NoSQL command)\",\r\n        \"analysis\": \"string (explanation)\"\r\n      }\r\n    ],\r\n    \"recommendation\": {\r\n      \"payloads\": {\r\n        \"field1\": \"payload string\",\r\n        \"field2\": \"payload string\"\r\n      },\r\n      \"reason\": \"string (why this payload should succeed)\"\r\n    }\r\n  }\r\n}\r\n\"\"\"\r\n    elif schema_class.__name__ == \"PlannerOutput\":\r\n        return \"\"\"\r\n{\r\n  \"final_output\": [\r\n    {\r\n      \"entry_point\": \"string (URL)\",\r\n      \"page_url\": \"string (URL of the page with the form)\",\r\n      \"payload_sequence\": [\r\n        {\r\n          \"type\": \"string (e.g., boolean, union)\",\r\n          \"payloads\": {\r\n            \"field_name_1\": \"payload string\",\r\n            \"field_name_2\": \"payload string\"\r\n          },\r\n          \"reason\": \"string (rationale)\"\r\n        }\r\n      ],\r\n      \"justification\": \"string (brief summary)\"\r\n    }\r\n  ]\r\n}\r\n\"\"\"\r\n    elif schema_class.__name__ == \"AttackerOutput\":\r\n        return \"\"\"\r\n{\r\n  \"final_output\": [\r\n    {\r\n      \"entry_point\": \"string (URL)\",\r\n      \"page_url\": \"string (URL of the page with the form)\",\r\n      \"payloads\": {\r\n        \"field_name\": \"payload string\"\r\n      },\r\n      \"response_excerpt\": \"string (excerpt of response)\",\r\n      \"notes\": \"string (observations)\"\r\n    }\r\n  ]\r\n}\r\n\"\"\"\r\n    elif schema_class.__name__ == \"ExploitEvaluatorOutput\":\r\n        return \"\"\"\r\n{\r\n  \"should_terminate\": boolean,\r\n  \"reason\": \"string (reason for verdict)\",\r\n  \"successful_payload\": null or {\r\n    \"field_name_1\": \"payload string\",\r\n    \"field_name_2\": \"payload string\"\r\n  }\r\n}\r\n\"\"\"\r\n    elif schema_class.__name__ == \"ScannerInputOutput\":\r\n        return \"\"\"\r\n{\r\n  \"scanner_tool_inputs\": {\r\n    \"target_url\": \"string (the URL to scan)\",\r\n    \"scan_depth\": \"number (how deep to crawl)\",\r\n    \"endpoints\": [\"list of endpoint URLs to test\"],\r\n    \"parameters\": {\r\n      \"additional\": \"scanner parameters\"\r\n    }\r\n  }\r\n}\r\n\"\"\"\r\n    \r\n    hints = schema_class.__annotations__\r\n    schema_desc = \"{\\n\"\r\n    for field_name, field_type in hints.items():\r\n        field_info = schema_class.__dict__.get(field_name)\r\n        desc = field_info.description if hasattr(field_info, 'description') else \"\"\r\n        type_str = str(field_type).replace(\"typing.\", \"\")\r\n        schema_desc += f'  \"{field_name}\": {type_str}'\r\n        if desc:\r\n            schema_desc += f'  // {desc}'\r\n        schema_desc += '\\n'\r\n    schema_desc += \"}\"\r\n    \r\n    return schema_desc\r\n\r\n\r\ndef safe_parse_json(content: str) -> dict:\r\n    \"\"\"\r\n    Safely parse JSON from model output, handling markdown code blocks.\r\n    \"\"\"\r\n    content = content.strip()\r\n    if content.startswith(\"```\"):\r\n        lines = content.split(\"\\n\")\r\n        lines = lines[1:]\r\n        if lines and lines[-1].strip() == \"```\":\r\n            lines = lines[:-1]\r\n        content = \"\\n\".join(lines).strip()\r\n    \r\n    try:\r\n        return json.loads(content)\r\n    except json.JSONDecodeError:\r\n        start = content.find('{')\r\n        end = content.rfind('}') + 1\r\n        if start != -1 and end > start:\r\n            return json.loads(content[start:end])\r\n        raise\r\n\r\n\r\nasync def call_ollama_with_json(model_name: str, prompt: str, schema_class: type, max_retries: int = 3, print_output: bool = True) -> dict:\r\n    \"\"\"\r\n    Call Ollama with JSON mode enabled and parse the response.\r\n    Includes retry logic for malformed JSON and server errors.\r\n    \r\n    Args:\r\n        model_name: Name of the Ollama model to use\r\n        prompt: The prompt to send to the model\r\n        schema_class: TypedDict class defining the expected output schema\r\n        max_retries: Maximum number of retry attempts\r\n        print_output: Whether to pretty print the output (default: True)\r\n    \r\n    Returns:\r\n        Parsed JSON dictionary matching the schema\r\n    \"\"\"\r\n    schema_name = schema_class.__name__\r\n    \r\n    for attempt in range(max_retries):\r\n        try:\r\n            llm = ChatOllama(\r\n                model=model_name,\r\n                format=\"json\",\r\n                temperature=0.1,\r\n                timeout=120,\r\n                verbose=False\r\n            )\r\n            schema_desc = get_json_schema_prompt(schema_class)\r\n            enhanced_prompt = f\"\"\"{prompt}\r\n\r\nCRITICAL: You MUST respond with a valid JSON object that EXACTLY matches this structure:\r\n{schema_desc}\r\n\r\nRULES:\r\n1. Return ONLY valid JSON\r\n2. NO explanations before or after the JSON\r\n3. NO markdown code blocks (no ```)\r\n4. NO additional text\r\n5. Ensure all required fields are present\r\n6. Follow the exact structure shown above\r\n\r\nYour response should start with {{ and end with }}\"\"\"\r\n            \r\n            response = await llm.ainvoke([HumanMessage(content=enhanced_prompt)])\r\n            result = safe_parse_json(response.content)\r\n            \r\n            if schema_name == \"CriticOutput\":\r\n                if \"final_output\" in result:\r\n                    if \"analysis\" not in result[\"final_output\"] or \"recommendation\" not in result[\"final_output\"]:\r\n                        raise ValueError(f\"Invalid CriticOutput structure. Missing required fields in final_output.\")\r\n                elif \"analysis\" in result and \"recommendation\" in result:\r\n                    result = {\"final_output\": result}\r\n                else:\r\n                    raise ValueError(f\"Invalid CriticOutput structure. Missing required fields.\")\r\n            \r\n            if print_output:\r\n                if schema_name == \"PlannerOutput\":\r\n                    print_planner_output(result)\r\n                elif schema_name == \"CriticOutput\":\r\n                    print_critic_output(result)\r\n                elif schema_name == \"AttackerOutput\":\r\n                    print_attacker_output(result)\r\n                elif schema_name == \"ExploitEvaluatorOutput\":\r\n                    print_evaluator_output(result)\r\n                elif schema_name == \"ScannerInputOutput\":\r\n                    print_scanner_input_output(result)\r\n            \r\n            return result\r\n            \r\n        except Exception as e:\r\n            print(f'Error on attempt {attempt + 1}/{max_retries}: {e}')\r\n            if attempt == max_retries - 1:\r\n                raise\r\n    \r\n    raise ValueError(f\"Failed to get valid JSON after {max_retries} attempts\")"
        }
    ]
}