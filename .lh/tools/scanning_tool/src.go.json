{
    "sourceFile": "tools/scanning_tool/src.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765822536474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765822536474,
            "name": "Commit-0",
            "content": "package main\r\n\r\nimport \"C\"\r\nimport (\r\n\t\"bufio\"\r\n\t\"bytes\"\r\n\t\"crypto/md5\"\r\n\t\"crypto/tls\"\r\n\t\"encoding/json\"\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"io/ioutil\"\r\n\t\"log\"\r\n\t\"net\"\r\n\t\"net/http\"\r\n\t\"net/url\"\r\n\t\"os\"\r\n\t\"reflect\"\r\n\t\"regexp\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\t\"time\"\r\n\r\n\t\"github.com/buger/jsonparser\"\r\n\t\"github.com/montanaflynn/stats\"\r\n)\r\n\r\n// data\r\nvar MongoSpecialCharacters = []string{\"'\", \"\\\"\", \"$\", \".\", \">\", \"[\", \"]\"}\r\nvar MongoSpecialKeyCharacters = []string{\"[$]\"}\r\nvar MongoJSONErrorAttacks = []string{`{\"foo\": 1}`}\r\nvar MongoPrefixes = []string{\"'\", \"\\\"\"}\r\nvar MongoGetInjection = []string{\"[$nin][]\", \"[$ne]\", \"[$gt]\", \"[$lt]\"}\r\nvar ObjectPrefixes = []string{\"\"}\r\nvar JSPrefixes = []string{\"\", \"'\", `\"`}\r\nvar JSSuffixes = []string{\"\", \"'\", `\"`, `//`, `'}//`}\r\nvar JSTrueStrings = []string{\r\n\t` && 'a'=='a' && 'a'=='a`,\r\n\t` || 'a'=='a' || 'a'=='a`,\r\n\t`;return true;`,\r\n}\r\nvar JSFalseStrings = []string{\r\n\t` && 'a'!='a' && 'a'!='a`,\r\n\t`;return false;`,\r\n}\r\nvar sleepPlaceholder = `TimeToSleep`\r\nvar JSTimingStringsRaw = []string{\r\n\t`;sleep(` + sleepPlaceholder + `);`,\r\n}\r\nvar JSTimingObjectInjectionsRaw = []string{\r\n\t`{\"$where\":  \"sleep(` + sleepPlaceholder + `)\"}`,\r\n}\r\n\r\nfunc JSTimingStrings(rawStrings []string, sleepTime int) []string {\r\n\tvar injections []string\r\n\tfor _, injection := range rawStrings {\r\n\t\tinjections = append(injections, strings.ReplaceAll(injection, sleepPlaceholder, strconv.Itoa(sleepTime)))\r\n\t}\r\n\treturn injections\r\n}\r\n\r\nvar ObjectInjectionsTrue = []string{\r\n\t`{\"$where\":  \"return true\"}`,\r\n\t`{\"$or\": [{},{\"foo\":\"1\"}]}`,\r\n\t//\t`,\"$or\": [{},{\"foo\":\"1\"}]`,\r\n}\r\nvar ObjectInjectionsFalse = []string{\r\n\t`{\"$where\":  \"return false\"}`,\r\n\t`{\"$or\": [{\"foo\":\"1\"},{\"foo\":\"1\"}]}`,\r\n}\r\nvar MongoErrorStrings = []string{\r\n\t`Uncaught MongoDB\\\\Driver\\\\Exception\\\\CommandException: unknown operator`,\r\n\t`(?i)MongoError`,\r\n\t`(?i)unterminated string literal`,\r\n}\r\nvar JSSyntaxErrorStrings = []string{`SyntaxError`}\r\nvar MongooseErrorStrings = []string{\r\n\t`(?i)Cast to string failed for value`, // Seen when object being passed when string expected. May indicate that objects will be parsed as objects.\r\n}\r\n\r\n// boolean blind\r\nfunc BlindBooleanInjectionTest(att AttackObject) []InjectionObject {\r\n\ti := iterateRegexGetBooleanInjections(att)\r\n\ti = append(i, iterateRegexPOSTBooleanInjections(att)...)\r\n\ti = append(i, iterateJSGetBooleanInjections(att)...)\r\n\ti = append(i, iterateJSPostBooleanInjections(att)...)\r\n\ti = append(i, iterateObjectInjections(att)...)\r\n\treturn i\r\n}\r\nfunc isBlindInjectable(baseline, trueRes, falseRes HTTPResponseObject) bool {\r\n\tif hasNOSQLError(falseRes.Body) || hasNOSQLError(trueRes.Body) {\r\n\t\t// Error response, which might indicate injection, but should be caught by error scanner\r\n\t\treturn false\r\n\t}\r\n\tif hasJSError(falseRes.Body) || hasJSError(trueRes.Body) {\r\n\t\t// JS error response - we probably have JS injection, but haven't found a proper boolean\r\n\t\t// test string yet.\r\n\t\treturn false\r\n\t}\r\n\tif baseline.ContentEquals(trueRes) && baseline.ContentEquals(falseRes) {\r\n\t\t// no difference in responses\r\n\t\treturn false\r\n\t}\r\n\tif baseline.ContentEquals(trueRes) && !baseline.ContentEquals(falseRes) {\r\n\t\treturn true\r\n\t}\r\n\tif !baseline.ContentEquals(trueRes) && baseline.ContentEquals(falseRes) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\nfunc runInjection(baseline, trueObject, falseObject AttackObject, key, injectedKey, trueVal, falseVal string) (InjectionObject, bool) {\r\n\tbaseline.IgnoreCache = true\r\n\ttrueObject.IgnoreCache = true\r\n\tfalseObject.IgnoreCache = true\r\n\r\n\tbaselineRes, err := baseline.Send()\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t}\r\n\r\n\ttrueRes, err := trueObject.Send()\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t}\r\n\r\n\tfalseRes, err := falseObject.Send()\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t}\r\n\tinjectable := InjectionObject{}\r\n\tif isBlindInjectable(baselineRes, trueRes, falseRes) {\r\n\t\tinjectable = InjectionObject{\r\n\t\t\tType:            Blind,\r\n\t\t\tAttackObject:    baseline,\r\n\t\t\tInjectableParam: key,\r\n\t\t\tInjectedParam:   injectedKey,\r\n\t\t\tInjectedValue:   \"true: \" + trueVal + \", false: \" + falseVal,\r\n\t\t}\r\n\t\treturn injectable, true\r\n\t}\r\n\treturn injectable, false\r\n}\r\nfunc iterateRegexGetBooleanInjections(att AttackObject) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\r\n\ttrueRegex := `.*`\r\n\tfalseRegex := `a^`\r\n\r\n\toriginal_params := att.QueryParams()\r\n\tkeys := make([]string, 0)\r\n\r\n\t// Get list of keys\r\n\tfor k, _ := range original_params {\r\n\t\tkeys = append(keys, k)\r\n\t}\r\n\r\n\tbaseline := att.Copy()\r\n\tbaseline2 := att.Copy()\r\n\t// Set all to empty keys, and see if we can still get a baseline - this will allow us to get\r\n\t// a full injection, unlike something like user=john.*, which might give a baseline of a single\r\n\t// record, we would prefer user=.*, though in some cases, we might still need to keep the prefix\r\n\tfor _, key := range keys {\r\n\t\tbaseline2.SetQueryParam(key, \"\")\r\n\t}\r\n\tbaselineRes2, err := baseline2.Send()\r\n\tif err == nil && !hasJSError(baselineRes2.Body) && !hasNOSQLError(baselineRes2.Body) {\r\n\t\tbaseline = baseline2\r\n\t}\r\n\r\n\t/**\r\n\t *\tSome apps will have multiple parameters that interact.\r\n\t *  so we need to ensure that we try every combination of\r\n\t *  parameters to maximize injection findings.\r\n\t */\r\n\tfor keylist := range StringCombinations(keys) {\r\n\t\t//for each combo, we will first set the value of each key to the always true regex\r\n\t\ttrueObj := baseline.Copy()\r\n\t\tfor _, key := range keylist {\r\n\t\t\tinjectedKey := key + `[$regex]`\r\n\t\t\ttrueObj.ReplaceQueryParam(key, injectedKey, trueRegex)\r\n\t\t}\r\n\r\n\t\t//Then test each key individually for boolean injection.\r\n\t\tfor _, key := range keylist {\r\n\t\t\tinjectedKey := key + `[$regex]`\r\n\t\t\tfalseObj := trueObj.Copy()\r\n\t\t\tfalseObj.SetQueryParam(injectedKey, falseRegex)\r\n\r\n\t\t\tinjectable, injectionSuccess := runInjection(baseline, trueObj, falseObj, key, injectedKey, trueRegex, falseRegex)\r\n\t\t\tif injectionSuccess {\r\n\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Unique(injectables)\r\n}\r\nfunc iterateRegexPOSTBooleanInjections(att AttackObject) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\r\n\tbaseline := att\r\n\ttrueRegex := `{\"$regex\": \".*\"}`\r\n\tfalseRegex := `{\"$regex\": \"a^\"}`\r\n\tinjectKeys := true\r\n\r\n\t/**\r\n\t *\tSome apps will have multiple parameters that interact.\r\n\t *  so we need to ensure that we try every combination of\r\n\t *  parameters to maximize injection findings.\r\n\t */\r\n\tfor keylist := range BodyItemCombinations(att.BodyValues) {\r\n\t\ttrueObj := baseline.Copy()\r\n\r\n\t\t//for each combo, we will first set the value of each key to the always true regex\r\n\t\tfor _, pattern := range keylist {\r\n\t\t\ttrueObj.ReplaceBodyObject(pattern.Value, trueRegex, injectKeys, pattern.Placement)\r\n\t\t}\r\n\t\tfalseObj := trueObj.Copy()\r\n\t\t//Then test each key individually for boolean injection.\r\n\t\tfor i, pattern := range keylist {\r\n\t\t\tfalseObj.ReplaceBodyObject(trueRegex, falseRegex, injectKeys, i)\r\n\r\n\t\t\tinjectable, injectionSuccess := runInjection(baseline, trueObj, falseObj, pattern.Value, pattern.Value, trueRegex, falseRegex)\r\n\t\t\tif injectionSuccess {\r\n\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t}\r\n\t\t\tfalseObj.ReplaceBodyObject(falseRegex, trueRegex, injectKeys, -1)\r\n\t\t}\r\n\t}\r\n\treturn Unique(injectables)\r\n}\r\nfunc iterateJSGetBooleanInjections(att AttackObject) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\r\n\toriginal_params := att.QueryParams()\r\n\tkeys := make([]string, 0)\r\n\r\n\t// Get list of keys\r\n\tfor k, _ := range original_params {\r\n\t\tkeys = append(keys, k)\r\n\t}\r\n\r\n\t/**\r\n\t *\tSome apps will have multiple parameters that interact.\r\n\t *  so we need to ensure that we try every combination of\r\n\t *  parameters to maximize injection findings.\r\n\t */\r\n\tfor _, quoteType := range []string{\"'\", \"\\\"\"} {\r\n\t\t// try with both single quoted and double quoted strings\r\n\t\tinjections := JSInjections(quoteType)\r\n\t\tfor keylist := range StringCombinations(keys) {\r\n\t\t\tfor trueJS, falseInjections := range injections {\r\n\t\t\t\t// Assign all keys in this combination to True\r\n\t\t\t\ttrueObj := att.Copy()\r\n\t\t\t\tfor _, key := range keylist {\r\n\t\t\t\t\ttrueObj.SetQueryParam(key, original_params[key]+trueJS)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfalseObj := trueObj.Copy()\r\n\t\t\t\tfor _, key := range keylist {\r\n\t\t\t\t\tfor _, falseJS := range falseInjections {\r\n\t\t\t\t\t\tinjection := original_params[key] + falseJS\r\n\t\t\t\t\t\tfalseObj.SetQueryParam(key, injection)\r\n\t\t\t\t\t\tinjectable, injectionSuccess := runInjection(att, trueObj, falseObj, key, key, original_params[key]+trueJS, injection)\r\n\t\t\t\t\t\tif injectionSuccess {\r\n\t\t\t\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfalseObj.SetQueryParam(key, original_params[key])\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Unique(injectables)\r\n}\r\nfunc iterateJSPostBooleanInjections(att AttackObject) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\r\n\t/**\r\n\t *\tSome apps will have multiple parameters that interact.\r\n\t *  so we need to ensure that we try every combination of\r\n\t *  parameters to maximize injection findings.\r\n\t */\r\n\tfor _, quoteType := range []string{\"'\"} {\r\n\t\t// try with both single quoted and double quoted strings\r\n\t\tinjections := JSInjections(quoteType)\r\n\t\tfor keylist := range BodyItemCombinations(att.BodyValues) {\r\n\t\t\tfor trueJS, falseInjections := range injections {\r\n\t\t\t\t// Assign all keys in this combination to True\r\n\r\n\t\t\t\ttrueObj := att.Copy()\r\n\t\t\t\tfor _, key := range keylist {\r\n\t\t\t\t\tinjection := `\"` + key.Value + trueJS + `\"`\r\n\t\t\t\t\ttrueObj.ReplaceBodyObject(key.Value, injection, false, key.Placement)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor i, key := range keylist {\r\n\t\t\t\t\tfor _, falseJS := range falseInjections {\r\n\t\t\t\t\t\tfalseObj := trueObj.Copy()\r\n\t\t\t\t\t\tinjection := `\"` + key.Value + falseJS + `\"`\r\n\t\t\t\t\t\tfalseObj.ReplaceBodyObject(key.Value+trueJS, injection, false, i)\r\n\t\t\t\t\t\tinjectable, injectionSuccess := runInjection(att, trueObj, falseObj, key.Value, key.Value, key.Value+trueJS, injection)\r\n\t\t\t\t\t\tif injectionSuccess {\r\n\t\t\t\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Unique(injectables)\r\n}\r\nfunc iterateObjectInjections(att AttackObject) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\r\n\ttrueRequest := att.Copy()\r\n\tfalseRequest := att.Copy()\r\n\tfor _, trueObject := range ObjectInjectionsTrue {\r\n\t\ttrueRequest.SetBody(trueObject)\r\n\t\tfor _, falseObject := range ObjectInjectionsFalse {\r\n\t\t\tfalseRequest.SetBody(falseObject)\r\n\t\t\tinjectable, injectionSuccess := runInjection(att, trueRequest, falseRequest, \"Body\", \"\", trueObject, falseObject)\r\n\t\t\tif injectionSuccess {\r\n\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Unique(injectables)\r\n}\r\n\r\n// error scanner\r\nfunc ErrorBasedInjectionTest(att AttackObject) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\tinjectables = append(injectables, injectSpecialCharsIntoQuery(att)...)\r\n\tinjectables = append(injectables, injectSpecialCharsIntoBody(att)...)\r\n\treturn injectables\r\n}\r\nfunc hasNOSQLError(body string) bool {\r\n\tmongoErrors := searchError(body, MongoErrorStrings)\r\n\tmongooseErrors := searchError(body, MongooseErrorStrings)\r\n\r\n\treturn mongoErrors || mongooseErrors\r\n}\r\nfunc hasJSError(body string) bool {\r\n\tjsErrors := searchError(body, JSSyntaxErrorStrings)\r\n\treturn jsErrors\r\n}\r\nfunc searchError(body string, errorList []string) bool {\r\n\tfor _, pattern := range errorList {\r\n\t\tmatched, err := regexp.MatchString(pattern, body)\r\n\t\tif err != nil {\r\n\t\t\tlog.Fatal(err)\r\n\t\t}\r\n\t\tif matched {\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\treturn false\r\n}\r\nfunc injectSpecialCharsIntoQuery(att AttackObject) []InjectionObject {\r\n\ti := iterateGetInjections(att, MongoSpecialCharacters, false)\r\n\ti = append(i, iterateGetInjections(att, MongoSpecialKeyCharacters, true)...)\r\n\treturn i\r\n}\r\nfunc injectSpecialCharsIntoBody(att AttackObject) []InjectionObject {\r\n\ti := iterateBodyInjections(att, MongoSpecialCharacters, false)\r\n\ti = append(i, iterateBodyInjections(att, MongoSpecialKeyCharacters, true)...)\r\n\ti = append(i, iterateBodyInjections(att, MongoJSONErrorAttacks, true)...)\r\n\treturn i\r\n}\r\nfunc iterateBodyInjections(att AttackObject, injectionList []string, injectKeys bool) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\tfor _, injection := range injectionList {\r\n\t\tfor _, pattern := range att.BodyValues {\r\n\t\t\tatt.ReplaceBodyObject(pattern.Value, injection, injectKeys, pattern.Placement)\r\n\t\t\tres, _ := att.Send()\r\n\t\t\tif hasNOSQLError(res.Body) {\r\n\t\t\t\tvar injectable = InjectionObject{\r\n\t\t\t\t\tType:            Error,\r\n\t\t\t\t\tAttackObject:    att,\r\n\t\t\t\t\tInjectableParam: pattern.Value,\r\n\t\t\t\t\tInjectedParam:   injection,\r\n\t\t\t\t}\r\n\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t}\r\n\r\n\t\t\tatt.RestoreBody() //reset value to default\r\n\t\t}\r\n\t}\r\n\treturn injectables\r\n}\r\nfunc iterateGetInjections(att AttackObject, injectionList []string, injectKeys bool) []InjectionObject {\r\n\tvar injectables []InjectionObject\r\n\tfor _, injection := range injectionList {\r\n\t\tfor k, v := range att.QueryParams() {\r\n\t\t\tinjectedValue := v\r\n\t\t\tinjectedKey := k\r\n\t\t\tif injectKeys {\r\n\t\t\t\tatt.ReplaceQueryParam(k, k+injection, v)\r\n\t\t\t\tinjectedKey = k + injection\r\n\t\t\t} else {\r\n\t\t\t\tatt.SetQueryParam(k, injection)\r\n\t\t\t\tinjectedValue = injection\r\n\t\t\t}\r\n\t\t\tres, _ := att.Send()\r\n\t\t\tif hasNOSQLError(res.Body) {\r\n\t\t\t\tvar injectable = InjectionObject{\r\n\t\t\t\t\tType:            Error,\r\n\t\t\t\t\tAttackObject:    att,\r\n\t\t\t\t\tInjectableParam: k,\r\n\t\t\t\t\tInjectedParam:   injectedKey,\r\n\t\t\t\t\tInjectedValue:   injectedValue,\r\n\t\t\t\t}\r\n\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t}\r\n\r\n\t\t\t//reset value to default\r\n\t\t\tif injectKeys {\r\n\t\t\t\tatt.ReplaceQueryParam(k+injection, k, v)\r\n\t\t\t} else {\r\n\t\t\t\tatt.SetQueryParam(k, v)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn injectables\r\n}\r\n\r\n// timing\r\nvar sleepTimeMS int = 500\r\n\r\nfunc TimingInjectionTest(att AttackObject) []InjectionObject {\r\n\tatt.IgnoreCache = true // Ensure we catch all instances of timing attacks\r\n\ti := iterateTimingGetInjections(att)\r\n\ti = append(i, iteratePostTimingInjections(att)...)\r\n\ti = append(i, iteratePostObjectInections(att)...)\r\n\tatt.IgnoreCache = false // return to default\r\n\treturn i\r\n}\r\nfunc measureRequest(request AttackObject) float64 {\r\n\tstart := time.Now()\r\n\t_, err := request.Send()\r\n\tif err != nil {\r\n\t\tfmt.Printf(\"Error sending request: %+v\\n\", err)\r\n\t}\r\n\td := time.Since(start)\r\n\treturn d.Seconds()\r\n}\r\nfunc baseline(att AttackObject) []float64 {\r\n\tvar baselineTimes []float64\r\n\r\n\tfor i := 0; i < 3; i++ {\r\n\t\tbaselineTimes = append(baselineTimes, measureRequest(att))\r\n\t}\r\n\treturn baselineTimes\r\n}\r\nfunc isTimingInjectable(baselines []float64, injectionTime float64) bool {\r\n\tdata := stats.LoadRawData(baselines)\r\n\tmean, _ := stats.Mean(data)\r\n\tstdDev, _ := stats.StdDevS(data)\r\n\r\n\tif injectionTime > (float64(sleepTimeMS)/1000) && injectionTime > (mean+2*stdDev) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\nfunc iterateTimingGetInjections(att AttackObject) []InjectionObject {\r\n\tbaselineTimes := baseline(att)\r\n\tvar injectables []InjectionObject\r\n\tparams := att.QueryParams()\r\n\r\n\tfor key := range params {\r\n\t\tfor _, prefix := range JSPrefixes {\r\n\t\t\tfor _, suffix := range JSSuffixes {\r\n\t\t\t\tfor _, tInjection := range JSTimingStrings(JSTimingStringsRaw, sleepTimeMS) {\r\n\t\t\t\t\tfor _, keepVal := range []string{\"\", params[key]} {\r\n\t\t\t\t\t\tattackObj := att.Copy()\r\n\t\t\t\t\t\tattackString := keepVal + prefix + tInjection + suffix\r\n\t\t\t\t\t\tattackObj.SetQueryParam(key, attackString)\r\n\t\t\t\t\t\ttiming := measureRequest(attackObj)\r\n\t\t\t\t\t\tif isTimingInjectable(baselineTimes, timing) {\r\n\t\t\t\t\t\t\tinjectable := InjectionObject{\r\n\t\t\t\t\t\t\t\tType:            Timed,\r\n\t\t\t\t\t\t\t\tAttackObject:    attackObj,\r\n\t\t\t\t\t\t\t\tInjectableParam: key,\r\n\t\t\t\t\t\t\t\tInjectedParam:   keepVal,\r\n\t\t\t\t\t\t\t\tInjectedValue:   attackString,\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn Unique(injectables)\r\n}\r\nfunc iteratePostTimingInjections(att AttackObject) []InjectionObject {\r\n\tbaselineTimes := baseline(att)\r\n\tvar injectables []InjectionObject\r\n\r\n\tfor _, bodyValue := range att.BodyValues {\r\n\t\tfor _, prefix := range JSPrefixes {\r\n\t\t\tfor _, suffix := range JSSuffixes {\r\n\t\t\t\tfor _, tInjection := range JSTimingStrings(JSTimingStringsRaw, sleepTimeMS) {\r\n\t\t\t\t\tfor _, keepVal := range []string{\"\", bodyValue.Value} {\r\n\t\t\t\t\t\tfor _, wrapQuote := range []string{\"\", \"\\\"\"} {\r\n\t\t\t\t\t\t\tattackObj := att.Copy()\r\n\t\t\t\t\t\t\tattackString := wrapQuote + keepVal + prefix + tInjection + suffix + wrapQuote\r\n\t\t\t\t\t\t\tattackObj.ReplaceBodyObject(bodyValue.Value, attackString, false, bodyValue.Placement)\r\n\t\t\t\t\t\t\ttiming := measureRequest(attackObj)\r\n\t\t\t\t\t\t\tif isTimingInjectable(baselineTimes, timing) {\r\n\t\t\t\t\t\t\t\tinjectable := InjectionObject{\r\n\t\t\t\t\t\t\t\t\tType:            Timed,\r\n\t\t\t\t\t\t\t\t\tAttackObject:    attackObj,\r\n\t\t\t\t\t\t\t\t\tInjectableParam: bodyValue.Value,\r\n\t\t\t\t\t\t\t\t\tInjectedParam:   bodyValue.Value,\r\n\t\t\t\t\t\t\t\t\tInjectedValue:   attackString,\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tinjectables = append(injectables, injectable)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn Unique(injectables)\r\n}\r\nfunc iteratePostObjectInections(att AttackObject) []InjectionObject {\r\n\tbaselineTimes := baseline(att)\r\n\tvar injectables []InjectionObject\r\n\r\n\ttimedRequest := att.Copy()\r\n\tfor _, tInjection := range JSTimingStrings(JSTimingObjectInjectionsRaw, sleepTimeMS) {\r\n\t\ttimedRequest.SetBody(tInjection)\r\n\t\ttiming := measureRequest(timedRequest)\r\n\t\tif isTimingInjectable(baselineTimes, timing) {\r\n\t\t\tinjectable := InjectionObject{\r\n\t\t\t\tType:            Timed,\r\n\t\t\t\tAttackObject:    timedRequest,\r\n\t\t\t\tInjectableParam: \"Whole Body\",\r\n\t\t\t\tInjectedParam:   \"Whole Body\",\r\n\t\t\t\tInjectedValue:   tInjection,\r\n\t\t\t}\r\n\t\t\tinjectables = append(injectables, injectable)\r\n\t\t}\r\n\t}\r\n\treturn Unique(injectables)\r\n}\r\n\r\n// utils\r\nvar injectionClient *http.Client = nil\r\n\r\ntype BodyItem struct {\r\n\tValue     string\r\n\tPlacement int\r\n}\r\ntype AttackObject struct {\r\n\tRequest      *http.Request\r\n\tClient       *http.Client\r\n\tOptions      ScanOptions\r\n\tBody         string\r\n\toriginalBody string     // Keep the original body, so we can reset it after injecting attack strings.\r\n\tBodyValues   []BodyItem // List of all values that can be updated. May include maps or arrays (if body is JSON) - but as Strings\r\n\tIgnoreCache  bool       // Whether to leverage the cache on requests.\r\n\trequestCache map[string]HTTPResponseObject\r\n}\r\n\r\nfunc NewAttackObject(options ScanOptions) (AttackObject, error) {\r\n\tattackObj := AttackObject{}\r\n\tattackObj.IgnoreCache = false\r\n\r\n\tattackObj.requestCache = make(map[string]HTTPResponseObject)\r\n\r\n\tif options.Request != \"\" {\r\n\t\tattackObj = parseRequest(options.Request, options)\r\n\r\n\t\tif options.UserAgentInput == \"\" {\r\n\t\t\toptions.UserAgentInput = attackObj.Request.Header.Get(\"User-Agent\")\r\n\t\t}\r\n\t} else if options.Target != \"\" {\r\n\t\tvar err error\r\n\t\tif options.RequireHTTPS {\r\n\t\t\tif options.Target[0:5] != \"https\" && options.Target[0:4] == \"http\" {\r\n\t\t\t\toptions.Target = \"https\" + options.Target[strings.Index(options.Target, \"://\"):]\r\n\t\t\t}\r\n\t\t}\r\n\t\tattackObj.Request, err = http.NewRequest(\"\", options.Target, nil)\r\n\t\tif err != nil {\r\n\t\t\tlog.Fatal(err)\r\n\t\t}\r\n\t} else {\r\n\t\treturn attackObj, errors.New(\"You must specify either a target or a request file to scan.\")\r\n\t}\r\n\r\n\tif options.RequestData != \"\" {\r\n\t\tattackObj.SetBody(options.RequestData)\r\n\t\tattackObj.Request.Header.Set(\"Content-Type\", \"application/json\")\r\n\t\tattackObj.Request.Header.Set(\"Accept\", \"application/json\")\r\n\t}\r\n\r\n\tattackObj.Options = options\r\n\tattackObj.addClient()\r\n\tattackObj.Request.Header.Set(\"User-Agent\", options.UserAgent())\r\n\treturn attackObj, nil\r\n}\r\nfunc parseRequest(file string, options ScanOptions) AttackObject {\r\n\tobj := AttackObject{}\r\n\tfh, err := os.Open(file)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tdefer fh.Close()\r\n\r\n\tdata := bufio.NewReader(fh)\r\n\tobj.Request, err = http.ReadRequest(data)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\r\n\tscheme := \"http\"\r\n\tif options.RequireHTTPS {\r\n\t\tscheme = \"https\"\r\n\t}\r\n\r\n\t// Update the request to make sure it is properly formed\r\n\tobj.Request.RequestURI = \"\"\r\n\tobj.Request.URL, err = url.Parse(scheme + \"://\" + obj.Request.Host + obj.Request.URL.String())\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\r\n\tbuf := new(bytes.Buffer)\r\n\tbuf.ReadFrom(obj.Request.Body)\r\n\tobj.Body = buf.String()\r\n\tobj.originalBody = obj.Body\r\n\tobj.extractUpdateableValuesFromBody()\r\n\r\n\treturn obj\r\n}\r\nfunc (a *AttackObject) addClient() {\r\n\tif injectionClient == nil {\r\n\t\tproxy := a.Options.Proxy()\r\n\t\ttransport := &http.Transport{\r\n\t\t\tDial: (&net.Dialer{\r\n\t\t\t\tTimeout: 30 * time.Second,\r\n\t\t\t}).Dial,\r\n\t\t\tTLSHandshakeTimeout: 10 * time.Second,\r\n\t\t\tMaxIdleConns:        20,\r\n\t\t\tDisableKeepAlives:   true,\r\n\t\t\tTLSClientConfig:     &tls.Config{InsecureSkipVerify: a.Options.AllowInsecureCertificates},\r\n\t\t}\r\n\t\tif proxy != \"\" {\r\n\t\t\tproxyURL, err := url.Parse(proxy)\r\n\t\t\tif err != nil {\r\n\t\t\t\tlog.Fatalf(\"Proxy not set correctly: %s\", err)\r\n\t\t\t} else {\r\n\t\t\t\tfmt.Printf(\"Using proxy %s\\n\", proxyURL)\r\n\t\t\t\ttransport.Proxy = http.ProxyURL(proxyURL)\r\n\t\t\t}\r\n\t\t}\r\n\t\tinjectionClient = &http.Client{\r\n\t\t\tTimeout:   10 * time.Second,\r\n\t\t\tTransport: transport,\r\n\t\t}\r\n\t}\r\n\ta.Client = injectionClient\r\n}\r\nfunc (a *AttackObject) Hash() string {\r\n\tserial := a.Body + a.Request.URL.String() + strconv.FormatBool(a.IgnoreCache) + a.Request.Method\r\n\tmd5 := md5.Sum([]byte(serial))\r\n\treturn string(md5[:])\r\n}\r\nfunc (a *AttackObject) Copy() AttackObject {\r\n\tattackObj, _ := NewAttackObject(a.Options)\r\n\tattackObj.Body = a.Body\r\n\tattackObj.IgnoreCache = a.IgnoreCache\r\n\tcopy(attackObj.BodyValues, a.BodyValues)\r\n\tattackObj.originalBody = a.originalBody\r\n\tattackObj.Request.URL.RawQuery = a.Request.URL.RawQuery\r\n\tattackObj.Request.Method = a.Request.Method\r\n\tattackObj.Request.Header = a.Request.Header.Clone()\r\n\treturn attackObj\r\n}\r\nfunc (a *AttackObject) SetURL(u string) {\r\n\tparsedURL, err := url.Parse(u)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\ta.Request.URL = parsedURL\r\n}\r\nfunc (a *AttackObject) QueryParams() map[string]string {\r\n\tq := a.Request.URL.Query()\r\n\tm := map[string]string{}\r\n\tfor k, v := range q {\r\n\t\tm[k] = v[0]\r\n\t}\r\n\treturn m\r\n}\r\nfunc (a *AttackObject) QueryString() string {\r\n\treturn a.Request.URL.RawQuery\r\n}\r\nfunc (a *AttackObject) SetQueryParam(key string, payload string) {\r\n\tq := a.Request.URL.Query()\r\n\tq[key][0] = payload\r\n\ta.Request.URL.RawQuery = q.Encode()\r\n}\r\nfunc (a *AttackObject) ReplaceQueryParam(oldkey string, key string, value string) {\r\n\tq := a.Request.URL.Query()\r\n\tq.Del(oldkey)\r\n\tq.Add(key, value)\r\n\ta.Request.URL.RawQuery = q.Encode()\r\n}\r\nfunc (a *AttackObject) setBodyQueryParam(pattern string, payload string, replaceKey bool) error {\r\n\tu, err := url.ParseRequestURI(\"/?\" + a.Body)\r\n\tif err != nil {\r\n\t\treturn err\r\n\t}\r\n\tq := u.Query()\r\n\tfor key, vSlice := range q {\r\n\t\tif replaceKey && key == pattern {\r\n\t\t\tq[payload] = vSlice\r\n\t\t\tdelete(q, key)\r\n\t\t} else {\r\n\t\t\tfor i, v := range vSlice {\r\n\t\t\t\tif url.QueryEscape(v) == pattern {\r\n\t\t\t\t\tvSlice[i] = payload\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tq[key] = vSlice\r\n\t\t}\r\n\t}\r\n\ta.Body = q.Encode()\r\n\treturn nil\r\n}\r\nfunc strReplace(source, pattern, replacement string, index int) string {\r\n\tif index == -1 {\r\n\t\treturn strings.ReplaceAll(source, pattern, replacement)\r\n\t} else {\r\n\t\tvar newBody string\r\n\t\tcomponents := strings.Split(source, pattern)\r\n\t\tfor i, substring := range components {\r\n\t\t\tif i == len(components)-1 {\r\n\t\t\t\tnewBody = newBody + substring\r\n\t\t\t\tif i == index && strings.HasSuffix(source, pattern) {\r\n\t\t\t\t\tnewBody = newBody + replacement\r\n\t\t\t\t}\r\n\t\t\t} else if i == index {\r\n\t\t\t\tnewBody = newBody + substring + replacement\r\n\t\t\t} else {\r\n\t\t\t\tnewBody = newBody + substring + pattern\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn newBody\r\n\t}\r\n}\r\nfunc (a *AttackObject) setBodyJSONParam(pattern string, payload string, replaceKey bool, index int) error {\r\n\tswitch jsonType(pattern) {\r\n\tcase \"string\":\r\n\t\t// string should be surrounded by double quotes\r\n\t\tpattern = `\"` + pattern + `\"`\r\n\t\ta.Body = strReplace(a.Body, pattern, payload, index)\r\n\tcase \"number\", \"boolean\", \"null\":\r\n\t\t// objects that are not enclosed with quotes should always be values (not keys)\r\n\t\t// and thus prefixed with a colon or object opener and zero or more spaces\r\n\t\t// they also should be followed by a comma, or closure of an array or object.\r\n\t\tpattern = `(?P<Prefix>[\\[,:]\\s*?)(?P<Payload>` + pattern + `)(?P<Suffix>\\s*?[,\\]\\}])`\r\n\t\tre := regexp.MustCompile(pattern)\r\n\t\tsubmatches := re.FindAllStringSubmatch(a.Body, -1)\r\n\t\tnames := re.SubexpNames()\r\n\t\tm := map[string]string{}\r\n\t\tm2 := []map[string]string{}\r\n\t\t// If we have multiple matches, they may have differing prefixes and suffixes\r\n\t\t// so we'll go through and create a new regex and payload to exact match each.\r\n\t\tfor count, submatch := range submatches {\r\n\t\t\tif index != -1 && index != count {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tm = make(map[string]string)\r\n\t\t\tfor i, n := range submatch {\r\n\t\t\t\tm[names[i]] = n\r\n\t\t\t}\r\n\t\t\tm2 = append(m2, m)\r\n\t\t}\r\n\t\tvar newRegex string\r\n\t\tvar newPayload string\r\n\t\tfor _, finding := range m2 {\r\n\t\t\tnewRegex = finding[\"Prefix\"] + finding[\"Payload\"] + finding[\"Suffix\"]\r\n\t\t\tnewPayload = finding[\"Prefix\"] + payload + finding[\"Suffix\"]\r\n\t\t\tre = regexp.MustCompile(newRegex)\r\n\t\t\ta.Body = re.ReplaceAllLiteralString(a.Body, newPayload)\r\n\t\t}\r\n\r\n\tdefault:\r\n\t\ta.Body = strReplace(a.Body, pattern, payload, index)\r\n\t}\r\n\treturn nil\r\n}\r\nfunc (a *AttackObject) ReplaceBodyObject(pattern string, payload string, replaceKey bool, index int) {\r\n\tif a.bodyIsJSON() {\r\n\t\ta.setBodyJSONParam(pattern, payload, replaceKey, index)\r\n\t} else {\r\n\t\ta.urlDecodeBody()\r\n\t\ta.setBodyQueryParam(pattern, payload, replaceKey)\r\n\t}\r\n\ta.Request.ContentLength = int64(len(a.Body))\r\n}\r\nfunc (a *AttackObject) bodyIsJSON() bool {\r\n\tcontentType := a.Request.Header.Get(\"Content-Type\")\r\n\tif contentType == \"application/json\" {\r\n\t\treturn true\r\n\t}\r\n\tif isJSON(a.Body) {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\nfunc (a *AttackObject) SetBody(body string) {\r\n\ta.Body = body\r\n\ta.originalBody = body\r\n\r\n\tif a.Body == \"\" {\r\n\t\ta.Request.Method = \"GET\"\r\n\t\treturn\r\n\t} else {\r\n\t\ta.Request.Method = \"POST\"\r\n\t}\r\n\r\n\tif isJSON(a.Body) {\r\n\t\ta.Request.Header.Set(\"Content-Type\", \"application/json\")\r\n\t} else {\r\n\t\ta.Request.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\r\n\t\ta.urlEncodeBody()\r\n\t\ta.originalBody = a.Body\r\n\t}\r\n\ta.extractUpdateableValuesFromBody()\r\n\ta.Request.ContentLength = int64(len(a.Body))\r\n}\r\nfunc (a *AttackObject) urlEncodeBody() {\r\n\tu, err := url.ParseRequestURI(\"/?\" + a.Body)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tq := u.Query()\r\n\ta.Body = q.Encode()\r\n}\r\nfunc (a *AttackObject) urlDecodeBody() {\r\n\tdecoded, err := url.QueryUnescape(a.Body)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t\treturn\r\n\t}\r\n\ta.Body = decoded\r\n}\r\nfunc (a *AttackObject) RestoreBody() {\r\n\ta.Body = a.originalBody\r\n\ta.Request.ContentLength = int64(len(a.Body))\r\n}\r\nfunc (a *AttackObject) extractUpdateableValuesFromBody() {\r\n\tvar values []string\r\n\tvalueCounter := map[string]int{}\r\n\r\n\tif isJSON(a.Body) {\r\n\t\tvalues = FlattenJSON(a.Body)\r\n\t} else {\r\n\t\tvalues = extractUpdateableQueryValuesFromBody(a.Body)\r\n\t}\r\n\r\n\tfor _, v := range values {\r\n\t\tif _, ok := valueCounter[v]; ok {\r\n\t\t\tvalueCounter[v]++\r\n\t\t} else {\r\n\t\t\tvalueCounter[v] = 0\r\n\t\t}\r\n\t\ta.BodyValues = append(a.BodyValues, BodyItem{v, valueCounter[v]})\r\n\t}\r\n}\r\nfunc extractUpdateableQueryValuesFromBody(body string) []string {\r\n\tvar values []string\r\n\tu, err := url.ParseRequestURI(\"/?\" + body)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tq := u.Query()\r\n\tfor k, v := range q {\r\n\t\tvalues = append(values, k)\r\n\t\tfor _, val := range v {\r\n\t\t\tvalues = append(values, val)\r\n\t\t}\r\n\t}\r\n\treturn values\r\n}\r\nfunc (a *AttackObject) setRequestBody() {\r\n\ta.Request.Body = ioutil.NopCloser(strings.NewReader(a.Body))\r\n}\r\n\r\nvar requestCache map[string]HTTPResponseObject = map[string]HTTPResponseObject{}\r\n\r\nfunc (a *AttackObject) Send() (HTTPResponseObject, error) {\r\n\tif !a.IgnoreCache {\r\n\t\tif res, ok := a.requestCache[a.Hash()]; ok {\r\n\t\t\treturn res, nil\r\n\t\t}\r\n\t}\r\n\r\n\ta.setRequestBody()\r\n\turl := a.Request.URL.String()\r\n\tobj := HTTPResponseObject{url, \"\", nil, 0}\r\n\r\n\t// fmt.Println(\"===================================\")\r\n\t// fmt.Println(\"âž¡ Sending Request\")\r\n\t// fmt.Println(\"URL:\", a.Request.URL.String())\r\n\t// fmt.Println(\"Method:\", a.Request.Method)\r\n\t// fmt.Println(\"Headers:\", a.Request.Header)\r\n\t// fmt.Println(\"Body:\", a.Body)\r\n\t// fmt.Println(\"===================================\")\r\n\r\n\tresp, err := a.Client.Do(a.Request)\r\n\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t\treturn obj, errors.New(\"Unable to retrieve url\")\r\n\t}\r\n\r\n\tobj.Header = resp.Header\r\n\tobj.StatusCode = resp.StatusCode\r\n\r\n\tdefer resp.Body.Close()\r\n\tbody, err := ioutil.ReadAll(resp.Body)\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t\treturn obj, errors.New(\"Unable to read response body\")\r\n\t}\r\n\r\n\tobj.Body = string(body)\r\n\ta.requestCache[a.Hash()] = obj\r\n\treturn obj, nil\r\n}\r\n\r\nfunc (this *HTTPResponseObject) DeepEquals(cmp HTTPResponseObject) bool {\r\n\theaderEquals := reflect.DeepEqual(this.Header, cmp.Header)\r\n\treturn this.ContentEquals(cmp) && headerEquals\r\n}\r\nfunc (this *HTTPResponseObject) ContentEquals(cmp HTTPResponseObject) bool {\r\n\tstatusEquals := this.StatusCode == cmp.StatusCode\r\n\tbodyEquals := this.Body == cmp.Body\r\n\treturn statusEquals && bodyEquals\r\n}\r\n\r\ntype HTTPResponseObject struct {\r\n\tUrl        string\r\n\tBody       string\r\n\tHeader     map[string][]string\r\n\tStatusCode int\r\n}\r\n\r\ntype InjectionType int\r\n\r\nconst (\r\n\tBlind = InjectionType(iota)\r\n\tTimed\r\n\tError\r\n\tGetParam\r\n)\r\n\r\nfunc (it InjectionType) String() string {\r\n\tswitch it {\r\n\tcase Blind:\r\n\t\treturn \"Blind NoSQL Injection\"\r\n\tcase Timed:\r\n\t\treturn \"Timing based NoSQL Injection\"\r\n\tcase Error:\r\n\t\treturn \"Error based NoSQL Injection\"\r\n\tcase GetParam:\r\n\t\treturn \"Get Parameter NoSQL Injection\"\r\n\t}\r\n\treturn \"\"\r\n}\r\n\r\ntype InjectionObject struct {\r\n\tType            InjectionType\r\n\tAttackObject    AttackObject\r\n\tInjectableParam string\r\n\tInjectedParam   string\r\n\tInjectedValue   string\r\n\tPrefix          string\r\n\tSuffix          string\r\n}\r\n\r\nfunc (i *InjectionObject) Print() {\r\n\tfmt.Print(i.String())\r\n}\r\nfunc (i *InjectionObject) String() string {\r\n\tvar b bytes.Buffer\r\n\tfmt.Fprintf(&b, \"Found %s:\\n\\tURL: %s\\n\\tparam: %s\\n\\tInjection: %s=%s\\n\\n\", i.Type, i.AttackObject.Request.URL, i.InjectableParam, i.InjectedParam, i.InjectedValue)\r\n\treturn b.String()\r\n}\r\nfunc (i *InjectionObject) Hash() string {\r\n\tserial := i.Type.String() + i.AttackObject.Request.URL.String() + i.InjectableParam + i.InjectedParam + i.InjectedValue\r\n\tmd5 := md5.Sum([]byte(serial))\r\n\treturn string(md5[:])\r\n}\r\nfunc Unique(injections []InjectionObject) []InjectionObject {\r\n\tfound := make(map[string]bool)\r\n\tvar uniques []InjectionObject\r\n\r\n\tfor _, injection := range injections {\r\n\t\tif !found[injection.Hash()] {\r\n\t\t\tuniques = append(uniques, injection)\r\n\t\t}\r\n\t\tfound[injection.Hash()] = true\r\n\t}\r\n\treturn uniques\r\n}\r\n\r\nfunc jsonType(jsonData string) string {\r\n\tb := []byte(jsonData)\r\n\t_, vtype, _, err := jsonparser.Get(b)\r\n\tif err != nil || vtype.String() == \"unknown\" {\r\n\t\treturn \"string\"\r\n\t} else {\r\n\t\treturn vtype.String()\r\n\t}\r\n}\r\nfunc FlattenJSON(jsonData string) []string {\r\n\tb := []byte(jsonData)\r\n\tvar s []string\r\n\treturn jsonObjectHandler(b, s)\r\n}\r\nfunc isJSON(s string) bool {\r\n\tvar js map[string]interface{}\r\n\terr := json.Unmarshal([]byte(s), &js)\r\n\treturn err == nil\r\n}\r\nfunc jsonArrayHandler(arrayData []byte, flattenedSlice []string) []string {\r\n\tjsonparser.ArrayEach(arrayData, func(value []byte, dataType jsonparser.ValueType, offset int, err error) {\r\n\t\tflattenedSlice = append(flattenedSlice, string(value))\r\n\t\tswitch dataType.String() {\r\n\t\tcase \"object\":\r\n\t\t\tflattenedSlice = jsonObjectHandler([]byte(string(value)), flattenedSlice)\r\n\t\tcase \"array\":\r\n\t\t\tflattenedSlice = jsonArrayHandler(value, flattenedSlice)\r\n\t\t}\r\n\t})\r\n\treturn flattenedSlice\r\n}\r\nfunc jsonObjectHandler(jsonData []byte, flattenedSlice []string) []string {\r\n\tjsonparser.ObjectEach(jsonData, func(key []byte, value []byte, dataType jsonparser.ValueType, offset int) error {\r\n\t\tflattenedSlice = append(flattenedSlice, string(key))\r\n\t\tflattenedSlice = append(flattenedSlice, string(value))\r\n\r\n\t\tswitch dataType.String() {\r\n\t\tcase \"object\":\r\n\t\t\tflattenedSlice = jsonObjectHandler(value, flattenedSlice)\r\n\t\tcase \"array\":\r\n\t\t\tflattenedSlice = jsonArrayHandler(value, flattenedSlice)\r\n\t\t}\r\n\t\treturn nil\r\n\t})\r\n\treturn flattenedSlice\r\n}\r\n\r\ntype ScanOptions struct {\r\n\tTarget                    string\r\n\tRequest                   string\r\n\tProxyInput                string\r\n\tUserAgentInput            string\r\n\tRequestData               string\r\n\tRequireHTTPS              bool\r\n\tAllowInsecureCertificates bool\r\n}\r\n\r\nfunc (s *ScanOptions) Proxy() string {\r\n\tif s.ProxyInput == \"\" {\r\n\t\treturn os.Getenv(\"HTTP_PROXY\")\r\n\t} else {\r\n\t\treturn s.ProxyInput\r\n\t}\r\n\r\n}\r\nfunc (s *ScanOptions) UserAgent() string {\r\n\treturn s.UserAgentInput\r\n}\r\n\r\nfunc Keys(aMap map[string]string) []string {\r\n\tkeys := make([]string, len(aMap))\r\n\ti := 0\r\n\tfor k, _ := range aMap {\r\n\t\tkeys[i] = k\r\n\t\ti++\r\n\t}\r\n\treturn keys\r\n}\r\nfunc Values(aMap map[string]string) []string {\r\n\tvalues := make([]string, len(aMap))\r\n\ti := 0\r\n\tfor _, v := range aMap {\r\n\t\tvalues[i] = v\r\n\t\ti++\r\n\t}\r\n\treturn values\r\n}\r\nfunc GetTransformedValues(kvList map[string]string, keyTransform func(string) string, valTransform func(string) string, transformKeys bool, transformValues bool) [][]map[string]string {\r\n\tvar result [][]map[string]string //list of new (kv) maps\r\n\tfor combo := range StringCombinations(Keys(kvList)) {\r\n\t\tvar comboObj []map[string]string\r\n\t\tfor _, k := range combo {\r\n\t\t\tvalues := make(map[string]string)\r\n\t\t\tvalues[\"oldkey\"] = k\r\n\t\t\tvalues[\"oldvalue\"] = kvList[k]\r\n\t\t\tvalues[\"newkey\"] = k\r\n\t\t\tvalues[\"newvalue\"] = kvList[k]\r\n\r\n\t\t\tif transformKeys {\r\n\t\t\t\tvalues[\"newkey\"] = keyTransform(k)\r\n\t\t\t}\r\n\t\t\tif transformValues {\r\n\t\t\t\tvalues[\"newvalue\"] = valTransform(kvList[k])\r\n\t\t\t}\r\n\t\t\tcomboObj = append(comboObj, values)\r\n\t\t}\r\n\t\tresult = append(result, comboObj)\r\n\t}\r\n\treturn result\r\n}\r\nfunc JSInjections(quoteType string) map[string][]string {\r\n\tattacks := map[string][]string{}\r\n\tfor _, prefix := range JSPrefixes {\r\n\t\tfor _, suffix := range JSSuffixes {\r\n\t\t\tfor _, tInjection := range JSTrueStrings {\r\n\t\t\t\ttInjection = prefix + tInjection + suffix\r\n\t\t\t\ttInjection = strings.ReplaceAll(tInjection, \"'\", quoteType)\r\n\t\t\t\tfor _, finjection := range JSFalseStrings {\r\n\t\t\t\t\tfinjection = prefix + finjection + suffix\r\n\t\t\t\t\tfinjection = strings.ReplaceAll(finjection, \"'\", quoteType)\r\n\t\t\t\t\tif _, ok := attacks[tInjection]; ok {\r\n\t\t\t\t\t\tattacks[tInjection] = append(attacks[tInjection], finjection)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tattacks[tInjection] = []string{finjection}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn attacks\r\n}\r\nfunc StringCombinations(data []string) <-chan []string {\r\n\tc := make(chan []string)\r\n\tiData := make([]interface{}, len(data))\r\n\tfor i, v := range data {\r\n\t\tiData[i] = v\r\n\t}\r\n\tgo func(c chan []string) {\r\n\t\tdefer close(c)\r\n\r\n\t\tfor combo := range Combinations(iData...) {\r\n\t\t\tsData := make([]string, len(combo))\r\n\t\t\tfor i, v := range combo {\r\n\t\t\t\tsData[i] = v.(string)\r\n\t\t\t}\r\n\t\t\tc <- sData\r\n\t\t}\r\n\t}(c)\r\n\r\n\treturn c\r\n}\r\nfunc BodyItemCombinations(data []BodyItem) <-chan []BodyItem {\r\n\tc := make(chan []BodyItem)\r\n\tiData := make([]interface{}, len(data))\r\n\tfor i, v := range data {\r\n\t\tiData[i] = v\r\n\t}\r\n\tgo func(c chan []BodyItem) {\r\n\t\tdefer close(c)\r\n\r\n\t\tfor combo := range Combinations(iData...) {\r\n\t\t\tsData := make([]BodyItem, len(combo))\r\n\t\t\tfor i, v := range combo {\r\n\t\t\t\tsData[i] = v.(BodyItem)\r\n\t\t\t}\r\n\t\t\tc <- sData\r\n\t\t}\r\n\t}(c)\r\n\r\n\treturn c\r\n}\r\nfunc Combinations(data ...interface{}) <-chan []interface{} {\r\n\tc := make(chan []interface{})\r\n\tgo func(c chan []interface{}) {\r\n\t\tdefer close(c)\r\n\r\n\t\tcombinationsGenerator(c, data)\r\n\t}(c)\r\n\r\n\treturn c\r\n}\r\nfunc combinationsGenerator(c chan []interface{}, set []interface{}) {\r\n\tlength := uint(len(set))\r\n\r\n\t// Go through all possible combinations of objects\r\n\t// from 0 (empty object in subset) to 2^length (all objects in subset)\r\n\tfor subsetBits := 1; subsetBits < (1 << length); subsetBits++ {\r\n\t\tvar subset []interface{}\r\n\r\n\t\tfor object := uint(0); object < length; object++ {\r\n\t\t\t// checks if object is contained in subset\r\n\t\t\t// by checking if bit 'object' is set in subsetBits\r\n\t\t\tif (subsetBits>>object)&1 == 1 {\r\n\t\t\t\t// add object to subset\r\n\t\t\t\tsubset = append(subset, set[object])\r\n\t\t\t}\r\n\t\t}\r\n\t\tc <- subset\r\n\t}\r\n}\r\nfunc Permutations(data []string) <-chan []string {\r\n\tc := make(chan []string)\r\n\r\n\tgo func(c chan []string) {\r\n\t\tdefer close(c)\r\n\r\n\t\tvar permutations []string\r\n\t\tgeneratePermutations(c, permutations, data)\r\n\t}(c)\r\n\r\n\treturn c\r\n}\r\nfunc generatePermutations(c chan []string, permutations []string, universe []string) {\r\n\tif len(universe) <= 0 {\r\n\t\treturn\r\n\t}\r\n\r\n\tvar permutation []string\r\n\tfor i, str := range universe {\r\n\t\tpermutation = append(permutation, str)\r\n\t\tc <- permutation\r\n\t\tnewUniverse := append([]string(nil), universe[:i]...) //ensure we copy the slice, and don't just point to the underlying array\r\n\t\tnewUniverse = append(newUniverse, universe[i+1:]...)\r\n\r\n\t\tgeneratePermutations(c, permutation, newUniverse)\r\n\t}\r\n}\r\n\r\n// main\r\nfunc display(injectables []InjectionObject) string {\r\n\tvar report strings.Builder\r\n\r\n\tfor _, in := range injectables {\r\n\t\treport.WriteString(in.String())\r\n\t}\r\n\r\n\tif len(injectables) == 0 {\r\n\t\treport.WriteString(\"No injections found.\\n\")\r\n\t}\r\n\r\n\treturn report.String()\r\n}\r\n\r\n//export run\r\nfunc run(urlPtr *C.char, requestDataPtr *C.char) *C.char {\r\n\ttarget := C.GoString(urlPtr)\r\n\trequestData := C.GoString(requestDataPtr)\r\n\r\n\tvar report strings.Builder\r\n\treport.WriteString(fmt.Sprintf(\"URL: %s\\n\", target))\r\n\treport.WriteString(fmt.Sprintf(\"Method: POST\\n\"))\r\n\r\n\trequireHTTPS := false\r\n\tuserAgent := \"Mozilla/5.0 (compatible; NoSQLi-Scanner/1.0)\"\r\n\trequest := \"\"\r\n\tallowInsecureCertificates := false\r\n\tproxy := \"\"\r\n\r\n\tvar scanOptions = ScanOptions{target, request, proxy, userAgent, requestData, requireHTTPS, allowInsecureCertificates}\r\n\tattackObj, err := NewAttackObject(scanOptions)\r\n\tif err != nil {\r\n\t\treturn C.CString(fmt.Sprintf(\"Error: %v\\n\", err))\r\n\t}\r\n\r\n\tattackObj.Request.Method = \"POST\"\r\n\r\n\tvar injectables []InjectionObject\r\n\treport.WriteString(\"Running Error based scan...\\n\")\r\n\tinjectables = append(injectables, ErrorBasedInjectionTest(attackObj)...)\r\n\treport.WriteString(\"Running Boolean based scan...\\n\")\r\n\tinjectables = append(injectables, BlindBooleanInjectionTest(attackObj)...)\r\n\treport.WriteString(\"Running Timing based scan...\\n\")\r\n\tinjectables = append(injectables, TimingInjectionTest(attackObj)...)\r\n\r\n\treport.WriteString(\"\\n=== RESULTS ===\\n\")\r\n\treport.WriteString(display(injectables))\r\n\r\n\treturn C.CString(report.String())\r\n}\r\n\r\nfunc main() {}\r\n"
        }
    ]
}