{
    "sourceFile": "tools/all_tools.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765741958893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765741958893,
            "name": "Commit-0",
            "content": "from typing import TypedDict, Optional, Union, Annotated\r\nimport os\r\nfrom langchain_chroma import Chroma\r\nimport json\r\nfrom langchain_core.documents import Document\r\n\r\nfrom langchain.tools.retriever import create_retriever_tool\r\nfrom langchain_community.agent_toolkits import FileManagementToolkit\r\nfrom langchain_community.utilities import GoogleSerperAPIWrapper\r\nfrom langchain_community.utilities.requests import TextRequestsWrapper\r\nfrom langchain_core.tools import Tool, tool\r\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter\r\nfrom langgraph.prebuilt import InjectedState\r\nfrom langgraph.prebuilt.chat_agent_executor import AgentStateWithStructuredResponse\r\nfrom langchain_ollama import OllamaEmbeddings\r\nfrom langchain_community.utilities.requests import TextRequestsWrapper\r\nfrom langchain_community.agent_toolkits.openapi.toolkit import RequestsToolkit\r\nfrom langchain_community.tools.playwright.utils import create_async_playwright_browser\r\nfrom tools.selenium.selenium import (\r\n    ClickButtonInput,\r\n    DescribeWebsiteInput,\r\n    FillOutFormInput,\r\n    FindFormInput,\r\n    GoogleSearchInput,\r\n    ScrollInput,\r\n    SeleniumWrapper,\r\n)\r\nfrom langchain.tools.base import BaseTool\r\n\r\nfrom typing import List\r\nfrom mcp_client import get_mcp_tools\r\n# NOTE: We do NOT import ScanForNoSQLITool here for scanner_input_tools\r\n# It will only be imported in the external scanner execution\r\n\r\nclass PentestState(AgentStateWithStructuredResponse):\r\n    tries: int\r\n    should_terminate: bool\r\n    reason: str\r\n    url: str\r\n    attempts: list[dict[str, Union[dict, str]]]\r\n    recommendation: dict\r\n    successful_payload: Union[None, dict[str, str]]\r\n    payloads: list\r\n    goal: str = \"\"\r\n\r\n    raw_attacker_output: Optional[str]\r\n    raw_planner_output: Optional[str]\r\n    raw_critic_output: Optional[str]\r\n    raw_scanner_input: Optional[str]  # NEW: for scanner input generator\r\n    scanner_tool_inputs: Optional[dict]  # NEW: structured scanner inputs\r\n    initial_scan_report: Optional[str]\r\n\r\n\r\nsearch = GoogleSerperAPIWrapper()\r\nsearch_tool = Tool(\r\n    name=\"search\",\r\n    func=search.run,\r\n    description=\"Use this to search the web for information\",\r\n)\r\n\r\ndef get_selenium_tools() -> List[BaseTool]:\r\n    \"\"\"Get the tools that will be used by the AI agent.\"\"\"\r\n    selenium = SeleniumWrapper()\r\n    tools: List[BaseTool] = [\r\n        Tool(\r\n            name=\"goto\",\r\n            func=selenium.describe_website,\r\n            description=\"useful for when you need visit a link or a website\",\r\n            args_schema=DescribeWebsiteInput,\r\n        ),\r\n        Tool(\r\n            name=\"click\",\r\n            func=selenium.click_button_by_text,\r\n            description=\"useful for when you need to click a button/link\",\r\n            args_schema=ClickButtonInput,\r\n        ),\r\n        Tool(\r\n            name=\"find_form\",\r\n            func=selenium.find_form_inputs,\r\n            description=(\r\n                \"useful for when you need to find out input forms given a url. Returns\"\r\n                \" the input fields to fill out\"\r\n            ),\r\n            args_schema=FindFormInput,\r\n        ),\r\n        Tool(\r\n            name=\"fill_form\",\r\n            func=selenium.fill_out_form,\r\n            description=(\r\n                \"useful for when you need to fill out a form on the current website.\"\r\n                \" Input should be a json formatted string\"\r\n            ),\r\n            args_schema=FillOutFormInput,\r\n        ),\r\n        Tool(\r\n            name=\"scroll\",\r\n            func=selenium.scroll,\r\n            description=(\r\n                \"useful for when you need to scroll up or down on the current website\"\r\n            ),\r\n            args_schema=ScrollInput,\r\n        ),\r\n        Tool(\r\n            name=\"google_search\",\r\n            func=selenium.google_search,\r\n            description=\"perform a google search\",\r\n            args_schema=GoogleSearchInput,\r\n        )\r\n    ]\r\n    return tools\r\n\r\n\r\n\r\ndef rag(json_path: str, name: str, description: str):\r\n    # Create a persistent directory for the vector store\r\n    persist_directory = \"vector_store\"\r\n    os.makedirs(persist_directory, exist_ok=True)\r\n    \r\n    print(\"Starting RAG initialization...\")\r\n    \r\n    # Initialize embeddings\r\n    print(\"Initializing Ollama embeddings...\")\r\n    embeddings = OllamaEmbeddings(\r\n        model=\"nomic-embed-text\",\r\n        base_url=\"http://localhost:11434\"\r\n    )\r\n    print(\"Ollama embeddings initialized...\")\r\n    \r\n    # Check if vector store exists and load/create accordingly\r\n    print(\"Checking for existing vector store...\")\r\n    \r\n    # Check if the vector store already exists\r\n    if os.path.exists(persist_directory) and any(os.scandir(persist_directory)):\r\n        # Load existing vector store\r\n        vectorstore = Chroma(\r\n            persist_directory=persist_directory, \r\n            embedding_function=embeddings\r\n        )\r\n        count = vectorstore._collection.count()\r\n        print(f\"Loaded existing vector store with {count} documents\")\r\n    else:\r\n        # Create new vector store from JSON\r\n        print(\"Creating new vector store from local JSON...\")\r\n\r\n        # Load from local JSON file\r\n        with open(json_path, \"r\", encoding=\"utf-8\") as f:\r\n            raw_docs = json.load(f)\r\n\r\n        docs_list = [\r\n            Document(page_content=doc[\"content\"], metadata=doc.get(\"metadata\", {}))\r\n            for doc in raw_docs\r\n        ]\r\n        print(f\"Loaded {len(docs_list)} documents from {json_path}\")\r\n\r\n        text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(\r\n            chunk_size=100, chunk_overlap=50\r\n        )\r\n        doc_splits = text_splitter.split_documents(docs_list)\r\n        print(f\"Split into {len(doc_splits)} chunks...\")\r\n\r\n        # Create new vector store with persistence\r\n        vectorstore = Chroma.from_documents(\r\n            documents=doc_splits,\r\n            embedding=embeddings,\r\n            persist_directory=persist_directory\r\n        )\r\n        print(\"Vector store created and persisted...\")\r\n    \r\n    retriever = vectorstore.as_retriever()\r\n    retriever_tool = create_retriever_tool(retriever, name, description)\r\n    print(\"RAG initialization complete!\")\r\n    return retriever_tool\r\n\r\nnosqli_rag_tool = rag(\r\n    json_path=\"nosqli_docs.json\", \r\n    name=\"retrieve_nosqli_information\",\r\n    description=\"Search and return information about NoSQL Injection and payloads from NoSQL Injection Cheat Sheets.\",\r\n)\r\n\r\nrequests_tools = RequestsToolkit(\r\n    requests_wrapper=TextRequestsWrapper(headers={}),\r\n    allow_dangerous_requests=True,\r\n).get_tools()\r\n\r\nfile_management_tools = FileManagementToolkit(\r\n    root_dir=str(\"sandbox\"),\r\n).get_tools()\r\n\r\n\r\n\r\n@tool\r\ndef get_attempts(state: Annotated[PentestState, InjectedState]) -> int:\r\n    \"\"\"\r\n    Returns the number of attempts made by the Pentest Agents.\r\n    \"\"\"\r\n    return state[\"tries\"]\r\n\r\n\r\nasync def scanner_input_tools():\r\n    \"\"\"\r\n    Tools for the scanner input generator agent.\r\n    This agent explores the site to determine what inputs to pass to the scanner,\r\n    but does NOT include the actual scanner tool itself.\r\n    \"\"\"\r\n    return (\r\n        (await get_mcp_tools(\"scanner_mcp.json\")) + \r\n        [search_tool] + \r\n        get_selenium_tools()\r\n        # NOTE: ScanForNoSQLITool() is NOT included here\r\n        # The scanner will be run externally after this agent generates inputs\r\n    )\r\n\r\n\r\nasync def planner_tools():\r\n    return (await get_mcp_tools(\"planner_mcp.json\")) + [search_tool, nosqli_rag_tool]\r\n\r\ndef attacker_tools():\r\n    return get_selenium_tools() + requests_tools\r\n\r\ndef report_writer_tools():\r\n    return file_management_tools + [search_tool]\r\n\r\n\r\n# Keep the old scanner_tools function for backwards compatibility if needed,\r\n# but mark it as deprecated\r\nasync def scanner_tools():\r\n    \"\"\"\r\n    DEPRECATED: This function is kept for backwards compatibility only.\r\n    Use scanner_input_tools() for the new workflow.\r\n    \"\"\"\r\n    from tools.scanning_tool.nosql_scanner import ScanForNoSQLITool\r\n    return (\r\n        (await get_mcp_tools(\"scanner_mcp.json\")) + \r\n        [search_tool, ScanForNoSQLITool()] + \r\n        get_selenium_tools()\r\n    )"
        }
    ]
}